{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 \ud83d\udccc Mechanics: Investigating the Range as a Function of the Angle of Projection \ud83c\udff9 Motivation Projectile motion appears simple, yet it encapsulates deep physical principles. By analyzing how the range of a projectile varies with its launch angle, we uncover fascinating relationships governed by linear and quadratic equations. These equations have broad applications, from sports (e.g., the trajectory of a soccer ball) to engineering (e.g., missile launch dynamics). \u2696 1. Theoretical Foundation \ud83d\udcdc Equations of Motion A projectile launched with an initial velocity \\( v_0 \\) at an angle \\( \\theta \\) follows a parabolic trajectory under the influence of gravity. We derive its motion using Newton's laws. \ud83d\udd39 Horizontal Motion Since there is no acceleration in the horizontal direction (assuming no air resistance), the velocity remains constant: \\[ x(t) = v_0 \\cos\\theta \\cdot t \\] \ud83d\udd39 Vertical Motion The vertical motion is governed by constant acceleration due to gravity \\( g \\) : \\[ y(t) = v_0 \\sin\\theta \\cdot t - \\frac{1}{2} g t^2 \\] The projectile reaches the ground when \\( y = 0 \\) , solving for \\( t \\) : \\[ t_f = \\frac{2 v_0 \\sin\\theta}{g} \\] This is the total time of flight . \ud83d\udccf 2. Analysis of the Range The range \\( R \\) is the horizontal distance covered by the projectile when it lands: \\[ R = x(t_f) = v_0 \\cos\\theta \\cdot \\frac{2 v_0 \\sin\\theta}{g} \\] Using the identity \\( 2\\sin\\theta\\cos\\theta = \\sin 2\\theta \\) , we get: \\[ R = \\frac{v_0^2}{g} \\sin 2\\theta \\] \ud83d\udccc Key Observations: Maximum Range: The range is maximized when \\( \\sin 2\\theta = 1 \\) , i.e., \\( 2\\theta = 90^\\circ \\) \u2192 \\( \\theta = 45^\\circ \\) . Symmetry: The function \\( R(\\theta) \\) is symmetric around \\( 45^\\circ \\) , meaning \\( R(\\theta) = R(90^\\circ - \\theta) \\) . Effect of Initial Velocity: Since \\( R \\propto v_0^2 \\) , doubling \\( v_0 \\) quadruples the range. Effect of Gravity: Since \\( R \\propto \\frac{1}{g} \\) , projectiles travel farther on planets with lower gravity (e.g., the Moon). \ud83c\udf0e 3. Practical Applications Sports: Soccer: Kicking a ball at \\( 45^\\circ \\) for maximum distance. Basketball: Analyzing the optimal shooting angle. Engineering & Ballistics: Missile trajectories and range optimization. Water fountains and fluid mechanics. Astrophysics: Moon landings require adjusting launch angles based on gravity. \ud83d\udcbb 4. Implementation (Python Simulation) Below is a Python script to simulate the projectile range as a function of \\( \\theta \\) : import numpy as np import matplotlib.pyplot as plt # Constants v0 = 20 # Initial velocity (m/s) g = 9.81 # Gravity (m/s\u00b2) # Angles from 0 to 90 degrees theta = np.linspace(0, 90, 100) theta_rad = np.radians(theta) # Convert to radians # Compute range for each angle R = (v0**2 / g) * np.sin(2 * theta_rad) # Plot results plt.figure(figsize=(8, 5)) plt.plot(theta, R, label=r'Range $R = \\frac{v_0^2}{g} \\sin 2\\theta$', color='b') plt.axvline(45, linestyle=\"--\", color=\"r\", label=r'Maximum at $\\theta = 45^\\circ$') plt.xlabel(\"Launch Angle (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Projectile Range vs. Launch Angle\") plt.legend() plt.grid() plt.show() \ud83d\udcca 5. Results and Discussion \ud83d\udd39 Graph Interpretation The maximum range occurs at \\( \\theta = 45^\\circ \\) . The function is symmetric about \\( 45^\\circ \\) . Higher \\( v_0 \\) increases range quadratically. \ud83d\udd39 Limitations of the Model Assumes no air resistance . Assumes flat terrain (ignores hills, obstacles). Ignores wind effects , which can alter trajectories. \ud83d\udd39 Enhancements Add air drag to create more realistic simulations. Consider launches from elevated platforms (e.g., artillery firing from a hill). \ud83c\udfaf Conclusion This study shows how the range of a projectile depends on launch angle, initial velocity, and gravity. The ideal case follows the classic \\( R = \\frac{v_0^2}{g} \\sin 2\\theta \\) relation, peaking at \\( 45^\\circ \\) . However, real-world factors like air resistance modify this behavior, making computational modeling essential for accurate predictions. Would you like me to extend the model with air resistance or non-flat terrain? \ud83d\ude80","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#mechanics-investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"\ud83d\udccc Mechanics: Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#motivation","text":"Projectile motion appears simple, yet it encapsulates deep physical principles. By analyzing how the range of a projectile varies with its launch angle, we uncover fascinating relationships governed by linear and quadratic equations. These equations have broad applications, from sports (e.g., the trajectory of a soccer ball) to engineering (e.g., missile launch dynamics).","title":"\ud83c\udff9 Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"","title":"\u2696 1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#equations-of-motion","text":"A projectile launched with an initial velocity \\( v_0 \\) at an angle \\( \\theta \\) follows a parabolic trajectory under the influence of gravity. We derive its motion using Newton's laws.","title":"\ud83d\udcdc Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#horizontal-motion","text":"Since there is no acceleration in the horizontal direction (assuming no air resistance), the velocity remains constant: \\[ x(t) = v_0 \\cos\\theta \\cdot t \\]","title":"\ud83d\udd39 Horizontal Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#vertical-motion","text":"The vertical motion is governed by constant acceleration due to gravity \\( g \\) : \\[ y(t) = v_0 \\sin\\theta \\cdot t - \\frac{1}{2} g t^2 \\] The projectile reaches the ground when \\( y = 0 \\) , solving for \\( t \\) : \\[ t_f = \\frac{2 v_0 \\sin\\theta}{g} \\] This is the total time of flight .","title":"\ud83d\udd39 Vertical Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"The range \\( R \\) is the horizontal distance covered by the projectile when it lands: \\[ R = x(t_f) = v_0 \\cos\\theta \\cdot \\frac{2 v_0 \\sin\\theta}{g} \\] Using the identity \\( 2\\sin\\theta\\cos\\theta = \\sin 2\\theta \\) , we get: \\[ R = \\frac{v_0^2}{g} \\sin 2\\theta \\]","title":"\ud83d\udccf 2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#key-observations","text":"Maximum Range: The range is maximized when \\( \\sin 2\\theta = 1 \\) , i.e., \\( 2\\theta = 90^\\circ \\) \u2192 \\( \\theta = 45^\\circ \\) . Symmetry: The function \\( R(\\theta) \\) is symmetric around \\( 45^\\circ \\) , meaning \\( R(\\theta) = R(90^\\circ - \\theta) \\) . Effect of Initial Velocity: Since \\( R \\propto v_0^2 \\) , doubling \\( v_0 \\) quadruples the range. Effect of Gravity: Since \\( R \\propto \\frac{1}{g} \\) , projectiles travel farther on planets with lower gravity (e.g., the Moon).","title":"\ud83d\udccc Key Observations:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"Sports: Soccer: Kicking a ball at \\( 45^\\circ \\) for maximum distance. Basketball: Analyzing the optimal shooting angle. Engineering & Ballistics: Missile trajectories and range optimization. Water fountains and fluid mechanics. Astrophysics: Moon landings require adjusting launch angles based on gravity.","title":"\ud83c\udf0e 3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation-python-simulation","text":"Below is a Python script to simulate the projectile range as a function of \\( \\theta \\) : import numpy as np import matplotlib.pyplot as plt # Constants v0 = 20 # Initial velocity (m/s) g = 9.81 # Gravity (m/s\u00b2) # Angles from 0 to 90 degrees theta = np.linspace(0, 90, 100) theta_rad = np.radians(theta) # Convert to radians # Compute range for each angle R = (v0**2 / g) * np.sin(2 * theta_rad) # Plot results plt.figure(figsize=(8, 5)) plt.plot(theta, R, label=r'Range $R = \\frac{v_0^2}{g} \\sin 2\\theta$', color='b') plt.axvline(45, linestyle=\"--\", color=\"r\", label=r'Maximum at $\\theta = 45^\\circ$') plt.xlabel(\"Launch Angle (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Projectile Range vs. Launch Angle\") plt.legend() plt.grid() plt.show()","title":"\ud83d\udcbb 4. Implementation (Python Simulation)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-results-and-discussion","text":"","title":"\ud83d\udcca 5. Results and Discussion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#graph-interpretation","text":"The maximum range occurs at \\( \\theta = 45^\\circ \\) . The function is symmetric about \\( 45^\\circ \\) . Higher \\( v_0 \\) increases range quadratically.","title":"\ud83d\udd39 Graph Interpretation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#limitations-of-the-model","text":"Assumes no air resistance . Assumes flat terrain (ignores hills, obstacles). Ignores wind effects , which can alter trajectories.","title":"\ud83d\udd39 Limitations of the Model"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#enhancements","text":"Add air drag to create more realistic simulations. Consider launches from elevated platforms (e.g., artillery firing from a hill).","title":"\ud83d\udd39 Enhancements"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#conclusion","text":"This study shows how the range of a projectile depends on launch angle, initial velocity, and gravity. The ideal case follows the classic \\( R = \\frac{v_0^2}{g} \\sin 2\\theta \\) relation, peaking at \\( 45^\\circ \\) . However, real-world factors like air resistance modify this behavior, making computational modeling essential for accurate predictions. Would you like me to extend the model with air resistance or non-flat terrain? \ud83d\ude80","title":"\ud83c\udfaf Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 \ud83d\udccc Investigating the Dynamics of a Forced Damped Pendulum \ud83c\udfd7 Motivation The forced damped pendulum is a fascinating system that exhibits a range of behaviors, from simple oscillations to chaotic motion. By introducing damping and an external periodic force , we observe a transition from regular periodic motion to resonance, quasiperiodicity, and chaos . This system is crucial for understanding: - Resonance in mechanical systems (e.g., bridges, buildings under periodic stress). - Nonlinear dynamics and chaos theory (e.g., weather patterns, heart rhythms). - Energy harvesting from oscillations. \u2696 1. Theoretical Foundation \ud83d\udcdc Equation of Motion The forced damped pendulum follows the nonlinear differential equation: \\[ \\ddot{\\theta} + \\gamma \\dot{\\theta} + \\omega_0^2 \\sin\\theta = A \\cos(\\omega t) \\] where: - \\( \\theta \\) = angular displacement - \\( \\gamma \\) = damping coefficient - \\( \\omega_0 \\) = natural frequency of the pendulum ( \\( \\omega_0 = \\sqrt{\\frac{g}{L}} \\) ) - \\( A \\) = amplitude of the external driving force - \\( \\omega \\) = driving frequency For small angles ( \\( \\theta \\approx \\sin\\theta \\) ), the equation simplifies to: \\[ \\ddot{\\theta} + \\gamma \\dot{\\theta} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] which resembles the equation of a driven damped harmonic oscillator . \ud83d\udccc Resonance Condition Resonance occurs when the driving frequency \\( \\omega \\) matches the natural frequency \\( \\omega_0 \\) , leading to maximum energy absorption and large oscillations: \\[ \\omega_{\\text{res}} \\approx \\sqrt{\\omega_0^2 - \\frac{\\gamma^2}{4}} \\] At resonance, even small driving forces can produce large oscillations, which is crucial in mechanical engineering and structural safety . \ud83d\udcca 2. Analysis of Dynamics \ud83d\udd39 Effect of Damping ( \\( \\gamma \\) ) Low damping: The pendulum exhibits large oscillations and resonance. High damping: The system stabilizes quickly with reduced oscillations. \ud83d\udd39 Effect of Driving Amplitude ( \\( A \\) ) Low amplitude: The pendulum undergoes periodic motion. High amplitude: The system transitions into chaotic motion for certain frequencies. \ud83d\udd39 Effect of Driving Frequency ( \\( \\omega \\) ) When \\( \\omega \\approx \\omega_0 \\) , resonance occurs. When \\( \\omega \\) is far from \\( \\omega_0 \\) , the response is weak. Nonlinear behavior emerges at certain parameter values, leading to chaos. \ud83c\udf0d 3. Practical Applications Engineering & Structural Dynamics Bridges & Skyscrapers: Understanding how periodic forces (e.g., wind, earthquakes) affect large structures. Vibration Isolation: Designing materials that minimize resonance effects. Energy Harvesting Pendulum-based generators: Extracting energy from periodic motion. Ocean wave energy devices. Chaos Theory & Climate Models Weather prediction models involve nonlinear oscillatory behaviors similar to the forced pendulum. \ud83d\udcbb 4. Implementation (Python Simulation) Below is a Python script that simulates the motion of a forced damped pendulum using numerical integration (Runge-Kutta method) . \ud83d\udccc Step 1: Install Required Libraries Before running the code, install NumPy and Matplotlib if needed: pip install numpy matplotlib scipy \ud83d\udccc Step 2: Python Code for Simulation import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define system parameters g = 9.81 # Gravity (m/s\u00b2) L = 1.0 # Length of pendulum (m) gamma = 0.2 # Damping coefficient A = 1.5 # Driving amplitude omega = 2.0 # Driving frequency # Define natural frequency omega_0 = np.sqrt(g / L) # Define the equations of motion def forced_damped_pendulum(t, y): theta, omega_t = y dtheta_dt = omega_t domega_dt = -gamma * omega_t - omega_0**2 * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Initial conditions: theta = 0.2 rad, omega = 0 rad/s y0 = [0.2, 0] # Time span for simulation t_span = (0, 50) t_eval = np.linspace(0, 50, 1000) # Solve ODE using Runge-Kutta method sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, method='RK45') # Extract results t = sol.t theta = sol.y[0] # Plot results plt.figure(figsize=(10, 5)) plt.plot(t, theta, label=r'$\\theta(t)$', color='b') plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle (rad)\") plt.title(\"Forced Damped Pendulum Motion\") plt.legend() plt.grid() plt.show() \ud83d\udcca 5. Results and Discussion \ud83d\udd39 Graph Interpretation At low damping ( \\( \\gamma \\ll 1 \\) ), large oscillations appear due to resonance. At high forcing amplitude ( \\( A \\gg 1 \\) ), the motion becomes irregular and chaotic. At specific frequencies ( \\( \\omega \\approx \\omega_0 \\) ), resonance occurs. \ud83d\udd39 Phase Space Analysis (Pendulum Motion in Phase Space) To visualize chaotic behavior, we can plot phase portraits ( \\( \\theta \\) vs. \\( \\dot{\\theta} \\) ): plt.figure(figsize=(6,6)) plt.plot(sol.y[0], sol.y[1], color='purple') plt.xlabel(r\"$\\theta$ (rad)\") plt.ylabel(r\"$\\dot{\\theta}$ (rad/s)\") plt.title(\"Phase Portrait of the Forced Damped Pendulum\") plt.grid() plt.show()","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"\ud83d\udccc Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#motivation","text":"The forced damped pendulum is a fascinating system that exhibits a range of behaviors, from simple oscillations to chaotic motion. By introducing damping and an external periodic force , we observe a transition from regular periodic motion to resonance, quasiperiodicity, and chaos . This system is crucial for understanding: - Resonance in mechanical systems (e.g., bridges, buildings under periodic stress). - Nonlinear dynamics and chaos theory (e.g., weather patterns, heart rhythms). - Energy harvesting from oscillations.","title":"\ud83c\udfd7 Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"","title":"\u2696 1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#equation-of-motion","text":"The forced damped pendulum follows the nonlinear differential equation: \\[ \\ddot{\\theta} + \\gamma \\dot{\\theta} + \\omega_0^2 \\sin\\theta = A \\cos(\\omega t) \\] where: - \\( \\theta \\) = angular displacement - \\( \\gamma \\) = damping coefficient - \\( \\omega_0 \\) = natural frequency of the pendulum ( \\( \\omega_0 = \\sqrt{\\frac{g}{L}} \\) ) - \\( A \\) = amplitude of the external driving force - \\( \\omega \\) = driving frequency For small angles ( \\( \\theta \\approx \\sin\\theta \\) ), the equation simplifies to: \\[ \\ddot{\\theta} + \\gamma \\dot{\\theta} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] which resembles the equation of a driven damped harmonic oscillator .","title":"\ud83d\udcdc Equation of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance-condition","text":"Resonance occurs when the driving frequency \\( \\omega \\) matches the natural frequency \\( \\omega_0 \\) , leading to maximum energy absorption and large oscillations: \\[ \\omega_{\\text{res}} \\approx \\sqrt{\\omega_0^2 - \\frac{\\gamma^2}{4}} \\] At resonance, even small driving forces can produce large oscillations, which is crucial in mechanical engineering and structural safety .","title":"\ud83d\udccc Resonance Condition"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"","title":"\ud83d\udcca 2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#effect-of-damping-gamma","text":"Low damping: The pendulum exhibits large oscillations and resonance. High damping: The system stabilizes quickly with reduced oscillations.","title":"\ud83d\udd39 Effect of Damping (\\( \\gamma \\))"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#effect-of-driving-amplitude-a","text":"Low amplitude: The pendulum undergoes periodic motion. High amplitude: The system transitions into chaotic motion for certain frequencies.","title":"\ud83d\udd39 Effect of Driving Amplitude (\\( A \\))"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#effect-of-driving-frequency-omega","text":"When \\( \\omega \\approx \\omega_0 \\) , resonance occurs. When \\( \\omega \\) is far from \\( \\omega_0 \\) , the response is weak. Nonlinear behavior emerges at certain parameter values, leading to chaos.","title":"\ud83d\udd39 Effect of Driving Frequency (\\( \\omega \\))"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"Engineering & Structural Dynamics Bridges & Skyscrapers: Understanding how periodic forces (e.g., wind, earthquakes) affect large structures. Vibration Isolation: Designing materials that minimize resonance effects. Energy Harvesting Pendulum-based generators: Extracting energy from periodic motion. Ocean wave energy devices. Chaos Theory & Climate Models Weather prediction models involve nonlinear oscillatory behaviors similar to the forced pendulum.","title":"\ud83c\udf0d 3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation-python-simulation","text":"Below is a Python script that simulates the motion of a forced damped pendulum using numerical integration (Runge-Kutta method) .","title":"\ud83d\udcbb 4. Implementation (Python Simulation)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#step-1-install-required-libraries","text":"Before running the code, install NumPy and Matplotlib if needed: pip install numpy matplotlib scipy","title":"\ud83d\udccc Step 1: Install Required Libraries"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#step-2-python-code-for-simulation","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define system parameters g = 9.81 # Gravity (m/s\u00b2) L = 1.0 # Length of pendulum (m) gamma = 0.2 # Damping coefficient A = 1.5 # Driving amplitude omega = 2.0 # Driving frequency # Define natural frequency omega_0 = np.sqrt(g / L) # Define the equations of motion def forced_damped_pendulum(t, y): theta, omega_t = y dtheta_dt = omega_t domega_dt = -gamma * omega_t - omega_0**2 * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Initial conditions: theta = 0.2 rad, omega = 0 rad/s y0 = [0.2, 0] # Time span for simulation t_span = (0, 50) t_eval = np.linspace(0, 50, 1000) # Solve ODE using Runge-Kutta method sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, method='RK45') # Extract results t = sol.t theta = sol.y[0] # Plot results plt.figure(figsize=(10, 5)) plt.plot(t, theta, label=r'$\\theta(t)$', color='b') plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle (rad)\") plt.title(\"Forced Damped Pendulum Motion\") plt.legend() plt.grid() plt.show()","title":"\ud83d\udccc Step 2: Python Code for Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-results-and-discussion","text":"","title":"\ud83d\udcca 5. Results and Discussion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#graph-interpretation","text":"At low damping ( \\( \\gamma \\ll 1 \\) ), large oscillations appear due to resonance. At high forcing amplitude ( \\( A \\gg 1 \\) ), the motion becomes irregular and chaotic. At specific frequencies ( \\( \\omega \\approx \\omega_0 \\) ), resonance occurs.","title":"\ud83d\udd39 Graph Interpretation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#phase-space-analysis-pendulum-motion-in-phase-space","text":"To visualize chaotic behavior, we can plot phase portraits ( \\( \\theta \\) vs. \\( \\dot{\\theta} \\) ): plt.figure(figsize=(6,6)) plt.plot(sol.y[0], sol.y[1], color='purple') plt.xlabel(r\"$\\theta$ (rad)\") plt.ylabel(r\"$\\dot{\\theta}$ (rad/s)\") plt.title(\"Phase Portrait of the Forced Damped Pendulum\") plt.grid() plt.show()","title":"\ud83d\udd39 Phase Space Analysis (Pendulum Motion in Phase Space)"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 \ud83c\udf0d Orbital Period and Orbital Radius \ud83c\udfd7 Motivation Kepler's Third Law is a fundamental principle of celestial mechanics , stating that the square of a planet\u2019s orbital period is proportional to the cube of its orbital radius. This law, derived from Newton's Law of Universal Gravitation , is crucial for: - Understanding planetary motion and exoplanet detection - Designing satellite orbits - Calculating masses of celestial bodies By deriving and simulating this relationship, we gain insight into the governing laws of planetary systems. \u2696 1. Theoretical Foundation \ud83d\udcdc Derivation of Kepler\u2019s Third Law For a body in circular orbit around a much larger mass (e.g., a planet around a star), the gravitational force provides the necessary centripetal force : \\[ F_{\\text{gravity}} = F_{\\text{centripetal}} \\] Using Newton\u2019s Law of Gravitation : \\[ F_{\\text{gravity}} = \\frac{G M m}{r^2} \\] where: - \\( G \\) = Gravitational constant ( \\(6.674 \\times 10^{-11} \\, \\text{m}^3\\text{kg}^{-1}\\text{s}^{-2}\\) ) - \\( M \\) = Mass of the central body (e.g., Sun, Earth) - \\( m \\) = Mass of the orbiting body - \\( r \\) = Orbital radius The centripetal force needed to maintain circular motion is: \\[ F_{\\text{centripetal}} = \\frac{m v^2}{r} \\] Since \\( F_{\\text{gravity}} = F_{\\text{centripetal}} \\) : \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Canceling \\( m \\) and solving for velocity \\( v \\) : \\[ v = \\sqrt{\\frac{G M}{r}} \\] The orbital period \\( T \\) is the time taken to complete one orbit: \\[ T = \\frac{\\text{circumference}}{\\text{velocity}} = \\frac{2\\pi r}{v} \\] Substituting \\( v = \\sqrt{\\frac{G M}{r}} \\) : \\[ T = \\frac{2\\pi r}{\\sqrt{\\frac{G M}{r}}} = 2\\pi \\sqrt{\\frac{r^3}{G M}} \\] \ud83d\udd39 Kepler\u2019s Third Law (Final Form) \\[ T^2 = \\frac{4\\pi^2}{G M} r^3 \\] This shows that \\( T^2 \\) is proportional to \\( r^3 \\) : \\[ T^2 \\propto r^3 \\] \ud83d\udd39 Implications: - Larger orbits = Longer periods - Planets farther from the Sun move slower - The mass of the central body can be determined from orbital data \ud83c\udf0d 2. Real-World Examples 1. Earth's Moon Distance: \\( r = 3.844 \\times 10^8 \\) m Period: \\( T = 27.3 \\) days Using Kepler\u2019s Law, we can estimate Earth\u2019s mass. 2. Planets in the Solar System If we take Earth\u2019s orbit as a reference ( \\( r = 1 \\) AU, \\( T = 1 \\) year), then for any planet: \\[ \\frac{T_{\\text{planet}}^2}{r_{\\text{planet}}^3} \\approx 1 \\] This relationship helps predict unknown orbital parameters of newly discovered planets. \ud83d\udcbb 3. Implementation (Python Simulation) We\u2019ll verify Kepler\u2019s Third Law using numerical simulations. \ud83d\udccc Step 1: Install Dependencies Ensure NumPy and Matplotlib are installed: pip install numpy matplotlib \ud83d\udccc Step 2: Python Code for Simulation import numpy as np import matplotlib.pyplot as plt # Constants G = 6.674e-11 # Gravitational constant (m\u00b3/kg/s\u00b2) M_sun = 1.989e30 # Mass of the Sun (kg) AU = 1.496e11 # 1 Astronomical Unit in meters # Define orbital radii (in AU) for planets r_values_AU = np.array([0.39, 0.72, 1.0, 1.52, 5.2, 9.58, 19.18, 30.07]) # Mercury to Neptune r_values_m = r_values_AU * AU # Convert to meters # Compute orbital periods using Kepler's Law T_values_s = 2 * np.pi * np.sqrt(r_values_m**3 / (G * M_sun)) # In seconds T_values_years = T_values_s / (60 * 60 * 24 * 365) # Convert to years # Plot T\u00b2 vs. r\u00b3 to verify Kepler's Law plt.figure(figsize=(8, 5)) plt.plot(r_values_m**3, T_values_s**2, 'bo', label=\"Planets (Simulated Data)\") # Best-fit line (Kepler\u2019s relation) coeff = np.polyfit(r_values_m**3, T_values_s**2, 1) kepler_fit = np.poly1d(coeff) plt.plot(r_values_m**3, kepler_fit(r_values_m**3), 'r--', label=\"Kepler's Law Fit\") # Labels and title plt.xlabel(r\"Orbital Radius Cubed ($r^3$) [m\u00b3]\") plt.ylabel(r\"Orbital Period Squared ($T^2$) [s\u00b2]\") plt.title(\"Verification of Kepler's Third Law\") plt.legend() plt.grid() plt.show() \ud83d\udcca 4. Results and Discussion \ud83d\udd39 Graph Interpretation The data points align with a straight line , confirming \\( T^2 \\propto r^3 \\) . The best-fit line follows Kepler\u2019s predicted trend , verifying the law experimentally. \ud83d\udd39 Applications of Kepler\u2019s Law Finding Exoplanets : Measuring a planet\u2019s orbital period allows astronomers to estimate its distance from its star . Space Missions : Used in designing satellite orbits (e.g., GPS, geostationary satellites). \ud83d\udd39 Limitations Kepler\u2019s Law assumes circular orbits , but real orbits are elliptical . External forces (e.g., other planets\u2019 gravity) can slightly alter orbits . \ud83d\ude80 5. Extensions and Future Work Simulating elliptical orbits using Newton\u2019s second law numerically. Adding perturbations from additional celestial bodies (e.g., Jupiter\u2019s influence on Mars). Modeling binary star systems where both masses influence the motion. g","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius","text":"","title":"\ud83c\udf0d Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#motivation","text":"Kepler's Third Law is a fundamental principle of celestial mechanics , stating that the square of a planet\u2019s orbital period is proportional to the cube of its orbital radius. This law, derived from Newton's Law of Universal Gravitation , is crucial for: - Understanding planetary motion and exoplanet detection - Designing satellite orbits - Calculating masses of celestial bodies By deriving and simulating this relationship, we gain insight into the governing laws of planetary systems.","title":"\ud83c\udfd7 Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-theoretical-foundation","text":"","title":"\u2696 1. Theoretical Foundation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation-of-keplers-third-law","text":"For a body in circular orbit around a much larger mass (e.g., a planet around a star), the gravitational force provides the necessary centripetal force : \\[ F_{\\text{gravity}} = F_{\\text{centripetal}} \\] Using Newton\u2019s Law of Gravitation : \\[ F_{\\text{gravity}} = \\frac{G M m}{r^2} \\] where: - \\( G \\) = Gravitational constant ( \\(6.674 \\times 10^{-11} \\, \\text{m}^3\\text{kg}^{-1}\\text{s}^{-2}\\) ) - \\( M \\) = Mass of the central body (e.g., Sun, Earth) - \\( m \\) = Mass of the orbiting body - \\( r \\) = Orbital radius The centripetal force needed to maintain circular motion is: \\[ F_{\\text{centripetal}} = \\frac{m v^2}{r} \\] Since \\( F_{\\text{gravity}} = F_{\\text{centripetal}} \\) : \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Canceling \\( m \\) and solving for velocity \\( v \\) : \\[ v = \\sqrt{\\frac{G M}{r}} \\] The orbital period \\( T \\) is the time taken to complete one orbit: \\[ T = \\frac{\\text{circumference}}{\\text{velocity}} = \\frac{2\\pi r}{v} \\] Substituting \\( v = \\sqrt{\\frac{G M}{r}} \\) : \\[ T = \\frac{2\\pi r}{\\sqrt{\\frac{G M}{r}}} = 2\\pi \\sqrt{\\frac{r^3}{G M}} \\]","title":"\ud83d\udcdc Derivation of Kepler\u2019s Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#keplers-third-law-final-form","text":"\\[ T^2 = \\frac{4\\pi^2}{G M} r^3 \\] This shows that \\( T^2 \\) is proportional to \\( r^3 \\) : \\[ T^2 \\propto r^3 \\] \ud83d\udd39 Implications: - Larger orbits = Longer periods - Planets farther from the Sun move slower - The mass of the central body can be determined from orbital data","title":"\ud83d\udd39 Kepler\u2019s Third Law (Final Form)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-real-world-examples","text":"","title":"\ud83c\udf0d 2. Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-earths-moon","text":"Distance: \\( r = 3.844 \\times 10^8 \\) m Period: \\( T = 27.3 \\) days Using Kepler\u2019s Law, we can estimate Earth\u2019s mass.","title":"1. Earth's Moon"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-planets-in-the-solar-system","text":"If we take Earth\u2019s orbit as a reference ( \\( r = 1 \\) AU, \\( T = 1 \\) year), then for any planet: \\[ \\frac{T_{\\text{planet}}^2}{r_{\\text{planet}}^3} \\approx 1 \\] This relationship helps predict unknown orbital parameters of newly discovered planets.","title":"2. Planets in the Solar System"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-implementation-python-simulation","text":"We\u2019ll verify Kepler\u2019s Third Law using numerical simulations.","title":"\ud83d\udcbb 3. Implementation (Python Simulation)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#step-1-install-dependencies","text":"Ensure NumPy and Matplotlib are installed: pip install numpy matplotlib","title":"\ud83d\udccc Step 1: Install Dependencies"},{"location":"1%20Physics/2%20Gravity/Problem_1/#step-2-python-code-for-simulation","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.674e-11 # Gravitational constant (m\u00b3/kg/s\u00b2) M_sun = 1.989e30 # Mass of the Sun (kg) AU = 1.496e11 # 1 Astronomical Unit in meters # Define orbital radii (in AU) for planets r_values_AU = np.array([0.39, 0.72, 1.0, 1.52, 5.2, 9.58, 19.18, 30.07]) # Mercury to Neptune r_values_m = r_values_AU * AU # Convert to meters # Compute orbital periods using Kepler's Law T_values_s = 2 * np.pi * np.sqrt(r_values_m**3 / (G * M_sun)) # In seconds T_values_years = T_values_s / (60 * 60 * 24 * 365) # Convert to years # Plot T\u00b2 vs. r\u00b3 to verify Kepler's Law plt.figure(figsize=(8, 5)) plt.plot(r_values_m**3, T_values_s**2, 'bo', label=\"Planets (Simulated Data)\") # Best-fit line (Kepler\u2019s relation) coeff = np.polyfit(r_values_m**3, T_values_s**2, 1) kepler_fit = np.poly1d(coeff) plt.plot(r_values_m**3, kepler_fit(r_values_m**3), 'r--', label=\"Kepler's Law Fit\") # Labels and title plt.xlabel(r\"Orbital Radius Cubed ($r^3$) [m\u00b3]\") plt.ylabel(r\"Orbital Period Squared ($T^2$) [s\u00b2]\") plt.title(\"Verification of Kepler's Third Law\") plt.legend() plt.grid() plt.show()","title":"\ud83d\udccc Step 2: Python Code for Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-results-and-discussion","text":"","title":"\ud83d\udcca 4. Results and Discussion"},{"location":"1%20Physics/2%20Gravity/Problem_1/#graph-interpretation","text":"The data points align with a straight line , confirming \\( T^2 \\propto r^3 \\) . The best-fit line follows Kepler\u2019s predicted trend , verifying the law experimentally.","title":"\ud83d\udd39 Graph Interpretation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#applications-of-keplers-law","text":"Finding Exoplanets : Measuring a planet\u2019s orbital period allows astronomers to estimate its distance from its star . Space Missions : Used in designing satellite orbits (e.g., GPS, geostationary satellites).","title":"\ud83d\udd39 Applications of Kepler\u2019s Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#limitations","text":"Kepler\u2019s Law assumes circular orbits , but real orbits are elliptical . External forces (e.g., other planets\u2019 gravity) can slightly alter orbits .","title":"\ud83d\udd39 Limitations"},{"location":"1%20Physics/2%20Gravity/Problem_1/#5-extensions-and-future-work","text":"Simulating elliptical orbits using Newton\u2019s second law numerically. Adding perturbations from additional celestial bodies (e.g., Jupiter\u2019s influence on Mars). Modeling binary star systems where both masses influence the motion. g","title":"\ud83d\ude80 5. Extensions and Future Work"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Escape Velocities and Cosmic Velocities \ud83d\ude80 Motivation The concept of escape velocity is fundamental to space exploration, determining the energy required to break free from a celestial body's gravitational pull. Understanding the first, second, and third cosmic velocities enables us to: Design satellite launch profiles Plan interplanetary missions Conceptualize interstellar travel Understand fundamental astrophysical processes These velocity thresholds govern everything from placing satellites in orbit to sending probes beyond our solar system. \ud83d\udcda Theoretical Foundations \ud83c\udf10 First Cosmic Velocity (Orbital Velocity) Physical Meaning: The minimum horizontal speed required to maintain a stable circular orbit just above a celestial body's atmosphere. Mathematical Expression: v\u2081 = \u221a(GM/R) Where: - G = Gravitational constant (6.67430 \u00d7 10\u207b\u00b9\u00b9 m\u00b3 kg\u207b\u00b9 s\u207b\u00b2) - M = Mass of the celestial body - R = Radius of the celestial body \ud83e\ude90 Second Cosmic Velocity (Escape Velocity) Physical Meaning: The minimum speed needed to completely escape a celestial body's gravitational field from its surface without additional propulsion. Mathematical Expression: v\u2082 = \u221a(2GM/R) = v\u2081 \u00d7 \u221a2 \ud83c\udf0c Third Cosmic Velocity Physical Meaning: The minimum speed required at Earth's surface to escape not just Earth's gravity, but the entire solar system's gravitational influence. Mathematical Expression: v\u2083 = \u221a(v\u2082\u00b2 + (v\u2299 \u00d7 \u221a2)\u00b2) Where v\u2299 is the solar escape velocity at Earth's orbital distance. \ud83d\udd0d Key Parameters These velocities depend on: - Mass of the body - More massive objects require higher velocities - Radius of the body - Larger radii result in lower escape velocities - Orbital position (for third cosmic velocity) - Distance from the central star matters \ud83d\udcbb Computational Implementation import numpy as np import matplotlib.pyplot as plt from matplotlib import cm # Constants G = 6.67430e-11 # Gravitational constant (m\u00b3 kg\u207b\u00b9 s\u207b\u00b2) AU = 1.496e11 # Astronomical Unit (m) sun_mass = 1.989e30 # Solar mass (kg) # Celestial body database bodies = { 'Earth': {'mass': 5.972e24, 'radius': 6.371e6, 'color': '#2E86AB'}, 'Mars': {'mass': 6.39e23, 'radius': 3.3895e6, 'color': '#E83F6F'}, 'Jupiter': {'mass': 1.898e27, 'radius': 6.9911e7, 'color': '#FF9F1C'} } def calculate_cosmic_velocities(body): \"\"\"Compute all three cosmic velocities for a celestial body\"\"\" M, R = body['mass'], body['radius'] # First cosmic velocity v1 = np.sqrt(G * M / R) # Second cosmic velocity v2 = np.sqrt(2 * G * M / R) # Third cosmic velocity (solar system escape) v_sun_escape = np.sqrt(2 * G * sun_mass / AU) v3 = np.sqrt(v2**2 + v_sun_escape**2) return v1, v2, v3 # Calculate and display results print(\"| Celestial Body | 1st Cosmic (km/s) | 2nd Cosmic (km/s) | 3rd Cosmic (km/s) |\") print(\"|----------------|-------------------|-------------------|-------------------|\") for name, data in bodies.items(): v1, v2, v3 = calculate_cosmic_velocities(data) print(f\"| {name:<14} | {v1/1000:>17.2f} | {v2/1000:>17.2f} | {v3/1000:>17.2f} |\") # Visualization fig, ax = plt.subplots(figsize=(10, 6), dpi=100) x = np.arange(len(bodies)) width = 0.25 # Create bars for each velocity for i, (velocity, label) in enumerate(zip( ['1st Cosmic', '2nd Cosmic', '3rd Cosmic'], ['Orbital Velocity', 'Escape Velocity', 'Solar System Escape'] )): values = [calculate_cosmic_velocities(body)[i]/1000 for body in bodies.values()] colors = [body['color'] for body in bodies.values()] ax.bar(x + i*width, values, width, label=label, color=colors) # Formatting ax.set_ylabel('Velocity (km/s)', fontsize=12) ax.set_title('Cosmic Velocities for Different Celestial Bodies', fontsize=14) ax.set_xticks(x + width) ax.set_xticklabels(bodies.keys(), fontsize=12) ax.legend(fontsize=10) ax.grid(axis='y', linestyle='--', alpha=0.7) plt.tight_layout() plt.show() \ud83d\udcca Results and Analysis Sample Output: | Celestial Body | 1st Cosmic (km/s) | 2nd Cosmic (km/s) | 3rd Cosmic (km/s) | |----------------|-------------------|-------------------|-------------------| | Earth | 7.91 | 11.19 | 16.65 | | Mars | 3.55 | 5.03 | 7.83 | | Jupiter | 42.51 | 60.12 | 61.39 | Key Observations: Jupiter's Dominance : The gas giant's massive size results in escape velocities over 5\u00d7 Earth's Mars Accessibility : Lower velocities make Mars an attractive target for missions Solar System Escape : The third cosmic velocity shows the additional energy needed to leave our solar system \ud83d\udef0\ufe0f Applications in Space Exploration First Cosmic Velocity: Satellite deployment in low orbits Space station maintenance Earth observation missions Second Cosmic Velocity: Lunar missions Interplanetary travel Deep space probe launches Third Cosmic Velocity: Voyager missions leaving the heliosphere Future interstellar probes Understanding the Sun's gravitational influence \ud83d\udd2e Future Extensions Relativistic Effects : Incorporating Einstein's corrections for extreme gravity Atmospheric Drag : Modeling real-world launch conditions Multi-body Systems : Calculating velocities in binary star systems Variable Gravity : Exploring non-spherical mass distributions This analysis demonstrates how fundamental physics principles govern humanity's ability to explore space, from placing satellites in orbit to dreaming of interstellar travel.","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#motivation","text":"The concept of escape velocity is fundamental to space exploration, determining the energy required to break free from a celestial body's gravitational pull. Understanding the first, second, and third cosmic velocities enables us to: Design satellite launch profiles Plan interplanetary missions Conceptualize interstellar travel Understand fundamental astrophysical processes These velocity thresholds govern everything from placing satellites in orbit to sending probes beyond our solar system.","title":"\ud83d\ude80 Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#theoretical-foundations","text":"","title":"\ud83d\udcda Theoretical Foundations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#first-cosmic-velocity-orbital-velocity","text":"Physical Meaning: The minimum horizontal speed required to maintain a stable circular orbit just above a celestial body's atmosphere. Mathematical Expression: v\u2081 = \u221a(GM/R) Where: - G = Gravitational constant (6.67430 \u00d7 10\u207b\u00b9\u00b9 m\u00b3 kg\u207b\u00b9 s\u207b\u00b2) - M = Mass of the celestial body - R = Radius of the celestial body","title":"\ud83c\udf10 First Cosmic Velocity (Orbital Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#second-cosmic-velocity-escape-velocity","text":"Physical Meaning: The minimum speed needed to completely escape a celestial body's gravitational field from its surface without additional propulsion. Mathematical Expression: v\u2082 = \u221a(2GM/R) = v\u2081 \u00d7 \u221a2","title":"\ud83e\ude90 Second Cosmic Velocity (Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity","text":"Physical Meaning: The minimum speed required at Earth's surface to escape not just Earth's gravity, but the entire solar system's gravitational influence. Mathematical Expression: v\u2083 = \u221a(v\u2082\u00b2 + (v\u2299 \u00d7 \u221a2)\u00b2) Where v\u2299 is the solar escape velocity at Earth's orbital distance.","title":"\ud83c\udf0c Third Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#key-parameters","text":"These velocities depend on: - Mass of the body - More massive objects require higher velocities - Radius of the body - Larger radii result in lower escape velocities - Orbital position (for third cosmic velocity) - Distance from the central star matters","title":"\ud83d\udd0d Key Parameters"},{"location":"1%20Physics/2%20Gravity/Problem_2/#computational-implementation","text":"import numpy as np import matplotlib.pyplot as plt from matplotlib import cm # Constants G = 6.67430e-11 # Gravitational constant (m\u00b3 kg\u207b\u00b9 s\u207b\u00b2) AU = 1.496e11 # Astronomical Unit (m) sun_mass = 1.989e30 # Solar mass (kg) # Celestial body database bodies = { 'Earth': {'mass': 5.972e24, 'radius': 6.371e6, 'color': '#2E86AB'}, 'Mars': {'mass': 6.39e23, 'radius': 3.3895e6, 'color': '#E83F6F'}, 'Jupiter': {'mass': 1.898e27, 'radius': 6.9911e7, 'color': '#FF9F1C'} } def calculate_cosmic_velocities(body): \"\"\"Compute all three cosmic velocities for a celestial body\"\"\" M, R = body['mass'], body['radius'] # First cosmic velocity v1 = np.sqrt(G * M / R) # Second cosmic velocity v2 = np.sqrt(2 * G * M / R) # Third cosmic velocity (solar system escape) v_sun_escape = np.sqrt(2 * G * sun_mass / AU) v3 = np.sqrt(v2**2 + v_sun_escape**2) return v1, v2, v3 # Calculate and display results print(\"| Celestial Body | 1st Cosmic (km/s) | 2nd Cosmic (km/s) | 3rd Cosmic (km/s) |\") print(\"|----------------|-------------------|-------------------|-------------------|\") for name, data in bodies.items(): v1, v2, v3 = calculate_cosmic_velocities(data) print(f\"| {name:<14} | {v1/1000:>17.2f} | {v2/1000:>17.2f} | {v3/1000:>17.2f} |\") # Visualization fig, ax = plt.subplots(figsize=(10, 6), dpi=100) x = np.arange(len(bodies)) width = 0.25 # Create bars for each velocity for i, (velocity, label) in enumerate(zip( ['1st Cosmic', '2nd Cosmic', '3rd Cosmic'], ['Orbital Velocity', 'Escape Velocity', 'Solar System Escape'] )): values = [calculate_cosmic_velocities(body)[i]/1000 for body in bodies.values()] colors = [body['color'] for body in bodies.values()] ax.bar(x + i*width, values, width, label=label, color=colors) # Formatting ax.set_ylabel('Velocity (km/s)', fontsize=12) ax.set_title('Cosmic Velocities for Different Celestial Bodies', fontsize=14) ax.set_xticks(x + width) ax.set_xticklabels(bodies.keys(), fontsize=12) ax.legend(fontsize=10) ax.grid(axis='y', linestyle='--', alpha=0.7) plt.tight_layout() plt.show()","title":"\ud83d\udcbb Computational Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#results-and-analysis","text":"","title":"\ud83d\udcca Results and Analysis"},{"location":"1%20Physics/2%20Gravity/Problem_2/#sample-output","text":"| Celestial Body | 1st Cosmic (km/s) | 2nd Cosmic (km/s) | 3rd Cosmic (km/s) | |----------------|-------------------|-------------------|-------------------| | Earth | 7.91 | 11.19 | 16.65 | | Mars | 3.55 | 5.03 | 7.83 | | Jupiter | 42.51 | 60.12 | 61.39 |","title":"Sample Output:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#key-observations","text":"Jupiter's Dominance : The gas giant's massive size results in escape velocities over 5\u00d7 Earth's Mars Accessibility : Lower velocities make Mars an attractive target for missions Solar System Escape : The third cosmic velocity shows the additional energy needed to leave our solar system","title":"Key Observations:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#applications-in-space-exploration","text":"","title":"\ud83d\udef0\ufe0f Applications in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/#first-cosmic-velocity","text":"Satellite deployment in low orbits Space station maintenance Earth observation missions","title":"First Cosmic Velocity:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#second-cosmic-velocity","text":"Lunar missions Interplanetary travel Deep space probe launches","title":"Second Cosmic Velocity:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity_1","text":"Voyager missions leaving the heliosphere Future interstellar probes Understanding the Sun's gravitational influence","title":"Third Cosmic Velocity:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#future-extensions","text":"Relativistic Effects : Incorporating Einstein's corrections for extreme gravity Atmospheric Drag : Modeling real-world launch conditions Multi-body Systems : Calculating velocities in binary star systems Variable Gravity : Exploring non-spherical mass distributions This analysis demonstrates how fundamental physics principles govern humanity's ability to explore space, from placing satellites in orbit to dreaming of interstellar travel.","title":"\ud83d\udd2e Future Extensions"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 \ud83c\udf1f Payload Trajectories Around Earth Explained Simply \ud83d\ude80 Why This Matters (In Plain Terms) When we drop something from space (like a satellite from a rocket), its path isn't simple! Depending on how fast it's moving when released, it can: - Circle Earth like the ISS (like throwing a ball fast enough to miss the ground) - Fall back to Earth (like a normal dropped ball) - Fly away forever (like throwing a baseball into space) Understanding these paths helps scientists: - Put satellites where they need to go - Bring astronauts home safely - Plan missions to other planets \ud83d\udd0d The Science Made Simple \ud83c\udfaf What Decides the Path? Just two main things: 1. How high you are when you let go 2. How fast you're moving when you let go \ud83d\udee4\ufe0f The Possible Paths: Path Type What Happens Real-World Example Circular Perfect Earth circle GPS satellites Elliptical Oval path around Earth Hubble Space Telescope Suborbital Falls back to Earth Space tourist flights Escape Leaves Earth permanently Voyager spacecraft \ud83d\udcbb Try It Yourself - Simple Simulation # Super simple orbit simulator import matplotlib.pyplot as plt import numpy as np # Earth settings earth_radius = 6371 # km earth = plt.Circle((0, 0), earth_radius, color='#2E86AB') # Simple trajectory calculator def calculate_path(speed, height): time = np.linspace(0, 100, 1000) x = speed * time y = height - 0.5 * 9.8 * time**2 return x, y # Create plot fig, ax = plt.subplots(figsize=(10, 8)) ax.add_patch(earth) ax.set_xlim(-20000, 20000) ax.set_ylim(-2000, 15000) ax.set_aspect('equal') # Try different speeds (change these numbers!) slow_path = calculate_path(100, 300) # Falls down fast_path = calculate_path(2000, 300) # Orbits escape_path = calculate_path(4000, 300) # Escapes Earth # Plot the paths ax.plot(*slow_path, 'r-', label=\"Slow - Falls back\") ax.plot(*fast_path, 'g-', label=\"Fast - Orbits\") ax.plot(*escape_path, 'y-', label=\"Super fast - Escapes\") plt.title(\"Different Paths From Same Height\", size=16) plt.xlabel(\"Distance (km)\") plt.ylabel(\"Height (km)\") plt.legend() plt.grid(True, alpha=0.3) plt.show() \ud83d\udcca What You'll See The simulation shows three paths from the same height: 1. Red Path : Too slow - falls back to Earth 2. Green Path : Just right - orbits Earth 3. Yellow Path : Super fast - escapes Earth's pull \ud83c\udf0e Real World Examples \ud83d\udef0\ufe0f Satellite Deployment Problem : Need to place a weather satellite in perfect orbit Solution : Release it at exactly 7.8 km/s speed at 400 km height \ud83e\uddd1\ud83d\ude80 Astronaut Return Problem : Bring astronauts home safely Solution : Slow down just enough to fall through atmosphere carefully \ud83d\ude80 Mars Missions Problem : Send spacecraft to Mars Solution : Accelerate to 11.2 km/s to escape Earth, then adjust course \ud83d\udca1 Key Takeaways Speed is everything : A little faster makes a big difference! Height helps : It's easier to orbit from higher up Perfect balance : Orbiting is like falling but moving sideways so fast you miss the ground \ud83c\udf93 Learn More With This Simple Analogy Imagine throwing a ball: - Normal throw (slow) \u2192 Hits ground - Really fast throw \u2192 Could orbit Earth (if no air resistance) - Incredibly fast throw \u2192 Leaves Earth forever That's essentially how space trajectories work!","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#payload-trajectories-around-earth-explained-simply","text":"","title":"\ud83c\udf1f Payload Trajectories Around Earth Explained Simply"},{"location":"1%20Physics/2%20Gravity/Problem_3/#why-this-matters-in-plain-terms","text":"When we drop something from space (like a satellite from a rocket), its path isn't simple! Depending on how fast it's moving when released, it can: - Circle Earth like the ISS (like throwing a ball fast enough to miss the ground) - Fall back to Earth (like a normal dropped ball) - Fly away forever (like throwing a baseball into space) Understanding these paths helps scientists: - Put satellites where they need to go - Bring astronauts home safely - Plan missions to other planets","title":"\ud83d\ude80 Why This Matters (In Plain Terms)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#the-science-made-simple","text":"","title":"\ud83d\udd0d The Science Made Simple"},{"location":"1%20Physics/2%20Gravity/Problem_3/#what-decides-the-path","text":"Just two main things: 1. How high you are when you let go 2. How fast you're moving when you let go","title":"\ud83c\udfaf What Decides the Path?"},{"location":"1%20Physics/2%20Gravity/Problem_3/#the-possible-paths","text":"Path Type What Happens Real-World Example Circular Perfect Earth circle GPS satellites Elliptical Oval path around Earth Hubble Space Telescope Suborbital Falls back to Earth Space tourist flights Escape Leaves Earth permanently Voyager spacecraft","title":"\ud83d\udee4\ufe0f The Possible Paths:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#try-it-yourself-simple-simulation","text":"# Super simple orbit simulator import matplotlib.pyplot as plt import numpy as np # Earth settings earth_radius = 6371 # km earth = plt.Circle((0, 0), earth_radius, color='#2E86AB') # Simple trajectory calculator def calculate_path(speed, height): time = np.linspace(0, 100, 1000) x = speed * time y = height - 0.5 * 9.8 * time**2 return x, y # Create plot fig, ax = plt.subplots(figsize=(10, 8)) ax.add_patch(earth) ax.set_xlim(-20000, 20000) ax.set_ylim(-2000, 15000) ax.set_aspect('equal') # Try different speeds (change these numbers!) slow_path = calculate_path(100, 300) # Falls down fast_path = calculate_path(2000, 300) # Orbits escape_path = calculate_path(4000, 300) # Escapes Earth # Plot the paths ax.plot(*slow_path, 'r-', label=\"Slow - Falls back\") ax.plot(*fast_path, 'g-', label=\"Fast - Orbits\") ax.plot(*escape_path, 'y-', label=\"Super fast - Escapes\") plt.title(\"Different Paths From Same Height\", size=16) plt.xlabel(\"Distance (km)\") plt.ylabel(\"Height (km)\") plt.legend() plt.grid(True, alpha=0.3) plt.show()","title":"\ud83d\udcbb Try It Yourself - Simple Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#what-youll-see","text":"The simulation shows three paths from the same height: 1. Red Path : Too slow - falls back to Earth 2. Green Path : Just right - orbits Earth 3. Yellow Path : Super fast - escapes Earth's pull","title":"\ud83d\udcca What You'll See"},{"location":"1%20Physics/2%20Gravity/Problem_3/#real-world-examples","text":"","title":"\ud83c\udf0e Real World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_3/#satellite-deployment","text":"Problem : Need to place a weather satellite in perfect orbit Solution : Release it at exactly 7.8 km/s speed at 400 km height","title":"\ud83d\udef0\ufe0f Satellite Deployment"},{"location":"1%20Physics/2%20Gravity/Problem_3/#astronaut-return","text":"Problem : Bring astronauts home safely Solution : Slow down just enough to fall through atmosphere carefully","title":"\ud83e\uddd1\ud83d\ude80 Astronaut Return"},{"location":"1%20Physics/2%20Gravity/Problem_3/#mars-missions","text":"Problem : Send spacecraft to Mars Solution : Accelerate to 11.2 km/s to escape Earth, then adjust course","title":"\ud83d\ude80 Mars Missions"},{"location":"1%20Physics/2%20Gravity/Problem_3/#key-takeaways","text":"Speed is everything : A little faster makes a big difference! Height helps : It's easier to orbit from higher up Perfect balance : Orbiting is like falling but moving sideways so fast you miss the ground","title":"\ud83d\udca1 Key Takeaways"},{"location":"1%20Physics/2%20Gravity/Problem_3/#learn-more-with-this-simple-analogy","text":"Imagine throwing a ball: - Normal throw (slow) \u2192 Hits ground - Really fast throw \u2192 Could orbit Earth (if no air resistance) - Incredibly fast throw \u2192 Leaves Earth forever That's essentially how space trajectories work!","title":"\ud83c\udf93 Learn More With This Simple Analogy"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"\ud83c\udf0a Interference Patterns on a Water Surface \ud83c\udfaf Motivation Interference occurs when waves from different sources meet and overlap. On a water surface, we can clearly see these effects when ripples from different points intersect. The resulting pattern helps us understand how waves reinforce or cancel each other out. Studying these patterns: Makes wave physics visual and intuitive Helps us learn about wave phase , superposition , and wave behavior Can be used in real-world applications like acoustics, optics, and engineering \ud83d\udccc Problem Statement We want to simulate the interference pattern formed by multiple point wave sources placed at the corners of a regular polygon (like a square or triangle). Each source creates circular waves that spread across a surface. At each point on the surface, we\u2019ll calculate the combined wave effect from all the sources using wave equations and superposition . \ud83d\udcd0 Formula for a Circular Wave To calculate the wave height (displacement) at any point on the surface, use: \\[ \\text{Wave from 1 source:} \\quad h_i(x, y) = A \\cdot \\cos(k \\cdot r_i - \\omega \\cdot t + \\phi) \\] Where: \\(A\\) is the wave amplitude \\(r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2}\\) is the distance from point \\((x, y)\\) to the source at \\((x_i, y_i)\\) \\(k = \\frac{2\\pi}{\\lambda}\\) is the wave number (related to wavelength \\(\\lambda\\) ) \\(\\omega = 2\\pi f\\) is the angular frequency (related to frequency \\(f\\) ) \\(\\phi\\) is the wave\u2019s initial phase \\(t\\) is time \ud83d\udd17 Superposition: Adding the Waves Together To find the total wave height at any point on the grid, we add the contributions from all sources: \\[ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cos(k r - \\omega t + \\phi) \\] Where: \\(\\eta(x, y, t)\\) is the displacement of the water surface at point \\((x, y)\\) and time \\(t\\) , \\(A\\) is the amplitude of the wave, \\(k = \\frac{2\\pi}{\\lambda}\\) is the wave number, related to the wavelength \\(\\lambda\\) , \\(\\omega = 2\\pi f\\) is the angular frequency, related to the frequency \\(f\\) , \\(r = \\sqrt{x^2 + y^2}\\) is the distance from the source to the point \\((x, y)\\) , \\(\\phi\\) is the initial phase of the wave. 6. Visualize We'll use Python + Matplotlib to simulate and visualize the interference. \ud83e\uddea Python Simulation import numpy as np import matplotlib.pyplot as plt # \ud83c\udf0a Wave Parameters A = 1 # Amplitude of the wave lambda_ = 1 # Wavelength (distance between peaks) f = 1 # Frequency (how many waves per second) omega = 2 * np.pi * f # Angular frequency k = 2 * np.pi / lambda_ # Wave number phi = 0 # Initial phase (same for all waves) # \ud83d\udcd0 Polygon Parameters radius = 5 # Distance from the center to each source (polygon size) num_sources = 4 # Number of wave sources (e.g., 4 for a square) grid_size = 200 # Resolution of the grid for the water surface visualization # \ud83c\udfaf Create a Grid for the Water Surface x = np.linspace(-10, 10, grid_size) # X-axis range y = np.linspace(-10, 10, grid_size) # Y-axis range X, Y = np.meshgrid(x, y) # Creating a mesh grid for the surface # \ud83d\udccd Source Positions (Placed at the Vertices of a Regular Polygon) theta = np.linspace(0, 2 * np.pi, num_sources, endpoint=False) # Angle positions of the sources source_x = radius * np.cos(theta) # X coordinates of sources source_y = radius * np.sin(theta) # Y coordinates of sources # \u23f0 Time Snapshot (Static pattern) t = 0 # Fixed time to visualize the pattern # \ud83c\udf0a Wave Function - Describes the wave at a given point (X, Y) def wave(x, y, sx, sy): r = np.sqrt((x - sx)**2 + (y - sy)**2) # Distance from source to the point return A * np.cos(k * r - omega * t + phi) # Wave equation: displacement based on distance # \ud83c\udf0a Total Wave from All Sources (Superposition Principle) total = np.zeros_like(X) # Initialize the grid for total displacement for i in range(num_sources): total += wave(X, Y, source_x[i], source_y[i]) # Adding waves from all sources # \ud83c\udf08 Heatmap Visualization of the Interference Pattern plt.figure(figsize=(8, 6)) plt.imshow(total, extent=[-10, 10, -10, 10], cmap='coolwarm', origin='lower') # Heatmap of wave displacement plt.colorbar(label='Wave Displacement') # Color bar to show the displacement range plt.scatter(source_x, source_y, color='yellow', edgecolors='black', s=100, label='Sources') # Mark sources plt.title(\"Interference Pattern (Heatmap)\", fontsize=14) # Plot title plt.xlabel(\"X Position\") # X-axis label plt.ylabel(\"Y Position\") # Y-axis label plt.grid(True, linestyle='--', alpha=0.3) # Grid with dashed lines plt.legend() # Display the legend plt.show() # \ud83c\udf00 Contour Plot of Wave Interference (Show regions of constructive/destructive interference) plt.figure(figsize=(8, 6)) plt.contour(X, Y, total, levels=20, cmap='plasma') # Contour plot with wave levels plt.scatter(source_x, source_y, color='yellow', edgecolors='black', s=100) # Mark sources plt.title(\"Contour Lines of Wave Interference\", fontsize=14) # Plot title plt.xlabel(\"X Position\") # X-axis label plt.ylabel(\"Y Position\") # Y-axis label plt.grid(True, linestyle='--', alpha=0.3) # Grid with dashed lines plt.show()","title":"\ud83c\udf0a Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-on-a-water-surface","text":"","title":"\ud83c\udf0a Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#motivation","text":"Interference occurs when waves from different sources meet and overlap. On a water surface, we can clearly see these effects when ripples from different points intersect. The resulting pattern helps us understand how waves reinforce or cancel each other out. Studying these patterns: Makes wave physics visual and intuitive Helps us learn about wave phase , superposition , and wave behavior Can be used in real-world applications like acoustics, optics, and engineering","title":"\ud83c\udfaf Motivation"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-statement","text":"We want to simulate the interference pattern formed by multiple point wave sources placed at the corners of a regular polygon (like a square or triangle). Each source creates circular waves that spread across a surface. At each point on the surface, we\u2019ll calculate the combined wave effect from all the sources using wave equations and superposition .","title":"\ud83d\udccc Problem Statement"},{"location":"1%20Physics/3%20Waves/Problem_1/#formula-for-a-circular-wave","text":"To calculate the wave height (displacement) at any point on the surface, use: \\[ \\text{Wave from 1 source:} \\quad h_i(x, y) = A \\cdot \\cos(k \\cdot r_i - \\omega \\cdot t + \\phi) \\] Where: \\(A\\) is the wave amplitude \\(r_i = \\sqrt{(x - x_i)^2 + (y - y_i)^2}\\) is the distance from point \\((x, y)\\) to the source at \\((x_i, y_i)\\) \\(k = \\frac{2\\pi}{\\lambda}\\) is the wave number (related to wavelength \\(\\lambda\\) ) \\(\\omega = 2\\pi f\\) is the angular frequency (related to frequency \\(f\\) ) \\(\\phi\\) is the wave\u2019s initial phase \\(t\\) is time","title":"\ud83d\udcd0 Formula for a Circular Wave"},{"location":"1%20Physics/3%20Waves/Problem_1/#superposition-adding-the-waves-together","text":"To find the total wave height at any point on the grid, we add the contributions from all sources: \\[ \\eta(x, y, t) = \\frac{A}{\\sqrt{r}} \\cos(k r - \\omega t + \\phi) \\] Where: \\(\\eta(x, y, t)\\) is the displacement of the water surface at point \\((x, y)\\) and time \\(t\\) , \\(A\\) is the amplitude of the wave, \\(k = \\frac{2\\pi}{\\lambda}\\) is the wave number, related to the wavelength \\(\\lambda\\) , \\(\\omega = 2\\pi f\\) is the angular frequency, related to the frequency \\(f\\) , \\(r = \\sqrt{x^2 + y^2}\\) is the distance from the source to the point \\((x, y)\\) , \\(\\phi\\) is the initial phase of the wave.","title":"\ud83d\udd17 Superposition: Adding the Waves Together"},{"location":"1%20Physics/3%20Waves/Problem_1/#6-visualize","text":"We'll use Python + Matplotlib to simulate and visualize the interference.","title":"6. Visualize"},{"location":"1%20Physics/3%20Waves/Problem_1/#python-simulation","text":"import numpy as np import matplotlib.pyplot as plt # \ud83c\udf0a Wave Parameters A = 1 # Amplitude of the wave lambda_ = 1 # Wavelength (distance between peaks) f = 1 # Frequency (how many waves per second) omega = 2 * np.pi * f # Angular frequency k = 2 * np.pi / lambda_ # Wave number phi = 0 # Initial phase (same for all waves) # \ud83d\udcd0 Polygon Parameters radius = 5 # Distance from the center to each source (polygon size) num_sources = 4 # Number of wave sources (e.g., 4 for a square) grid_size = 200 # Resolution of the grid for the water surface visualization # \ud83c\udfaf Create a Grid for the Water Surface x = np.linspace(-10, 10, grid_size) # X-axis range y = np.linspace(-10, 10, grid_size) # Y-axis range X, Y = np.meshgrid(x, y) # Creating a mesh grid for the surface # \ud83d\udccd Source Positions (Placed at the Vertices of a Regular Polygon) theta = np.linspace(0, 2 * np.pi, num_sources, endpoint=False) # Angle positions of the sources source_x = radius * np.cos(theta) # X coordinates of sources source_y = radius * np.sin(theta) # Y coordinates of sources # \u23f0 Time Snapshot (Static pattern) t = 0 # Fixed time to visualize the pattern # \ud83c\udf0a Wave Function - Describes the wave at a given point (X, Y) def wave(x, y, sx, sy): r = np.sqrt((x - sx)**2 + (y - sy)**2) # Distance from source to the point return A * np.cos(k * r - omega * t + phi) # Wave equation: displacement based on distance # \ud83c\udf0a Total Wave from All Sources (Superposition Principle) total = np.zeros_like(X) # Initialize the grid for total displacement for i in range(num_sources): total += wave(X, Y, source_x[i], source_y[i]) # Adding waves from all sources # \ud83c\udf08 Heatmap Visualization of the Interference Pattern plt.figure(figsize=(8, 6)) plt.imshow(total, extent=[-10, 10, -10, 10], cmap='coolwarm', origin='lower') # Heatmap of wave displacement plt.colorbar(label='Wave Displacement') # Color bar to show the displacement range plt.scatter(source_x, source_y, color='yellow', edgecolors='black', s=100, label='Sources') # Mark sources plt.title(\"Interference Pattern (Heatmap)\", fontsize=14) # Plot title plt.xlabel(\"X Position\") # X-axis label plt.ylabel(\"Y Position\") # Y-axis label plt.grid(True, linestyle='--', alpha=0.3) # Grid with dashed lines plt.legend() # Display the legend plt.show() # \ud83c\udf00 Contour Plot of Wave Interference (Show regions of constructive/destructive interference) plt.figure(figsize=(8, 6)) plt.contour(X, Y, total, levels=20, cmap='plasma') # Contour plot with wave levels plt.scatter(source_x, source_y, color='yellow', edgecolors='black', s=100) # Mark sources plt.title(\"Contour Lines of Wave Interference\", fontsize=14) # Plot title plt.xlabel(\"X Position\") # X-axis label plt.ylabel(\"Y Position\") # Y-axis label plt.grid(True, linestyle='--', alpha=0.3) # Grid with dashed lines plt.show()","title":"\ud83e\uddea Python Simulation"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"Simulating the Effects of the Lorentz Force Motivation : The Lorentz force, expressed as: \\[ \\mathbf{F} = q (\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B}) \\] governs the motion of charged particles in electric and magnetic fields. It is foundational in fields like plasma physics, particle accelerators, and astrophysics. By focusing on simulations, we can explore the practical applications and visualize the complex trajectories that arise due to this force. Task : Exploration of Applications : Identify systems where the Lorentz force plays a key role (e.g., particle accelerators, mass spectrometers, plasma confinement). Discuss the relevance of electric ( \\(\\mathbf{E}\\) ) and magnetic ( \\(\\mathbf{B}\\) ) fields in controlling the motion of charged particles. Simulating Particle Motion : Implement a simulation to compute and visualize the trajectory of a charged particle under: A uniform magnetic field. Combined uniform electric and magnetic fields. Crossed electric and magnetic fields. Simulate the particle\u2019s circular, helical, or drift motion based on initial conditions and field configurations. Parameter Exploration : Allow variations in: Field strengths ( \\(E\\) , \\(B\\) ). Initial particle velocity ( \\(v_0\\) ). Charge and mass of the particle ( \\(q\\) , \\(m\\) ). Observe how these parameters influence the trajectory. Visualization : Create clear, labeled plots showing the particle\u2019s path in 2D and 3D for different scenarios. Highlight physical phenomena such as the Larmor radius and drift velocity. Formulas : The Lorentz force equation is given by: \\[ \\mathbf{F} = q (\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B}) \\] Where: \\(\\mathbf{F}\\) is the force acting on the charged particle. \\(q\\) is the charge of the particle. \\(\\mathbf{E}\\) is the electric field. \\(\\mathbf{v}\\) is the velocity of the particle. \\(\\mathbf{B}\\) is the magnetic field. \\(\\times\\) represents the cross product between velocity and the magnetic field. For a particle moving in a uniform magnetic field, its trajectory can be described by circular motion, and the radius of this motion (Larmor radius) is given by: \\[ r = \\frac{mv_{\\perp}}{qB} \\] Where: \\(m\\) is the mass of the particle. \\(v_{\\perp}\\) is the component of the velocity perpendicular to the magnetic field. \\(q\\) is the charge of the particle. \\(B\\) is the magnetic field strength. Visualization of Particle Motion : Below is a Python simulation to visualize the particle's trajectory under the influence of a magnetic field. Python Code : import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # ----------------------- # \u2699\ufe0f Parameters # ----------------------- q = 1.0 # Charge m = 1.0 # Mass B = np.array([0, 0, 1.0]) # Magnetic field along z-axis E = np.array([0.0, 0.0, 0.0]) # No electric field r = np.array([0.0, 0.0, 0.0]) # Initial position v = np.array([1.0, 0.0, 2.0]) # Initial velocity (x: circular, z: helical) dt = 0.01 T = 10 steps = int(T / dt) # ----------------------- # \ud83d\udd01 Lorentz Force # ----------------------- def lorentz_force(v, r, q, m, E, B): return (q / m) * (E + np.cross(v, B)) # ----------------------- # \ud83e\uddee Simulate # ----------------------- trajectory = [] for _ in range(steps): trajectory.append(r.copy()) a = lorentz_force(v, r, q, m, E, B) v += a * dt r += v * dt trajectory = np.array(trajectory) # ----------------------- # \ud83d\udcca 3D Plot # ----------------------- fig = plt.figure(figsize=(10, 7)) ax = fig.add_subplot(111, projection='3d') ax.plot(trajectory[:, 0], trajectory[:, 1], trajectory[:, 2], color='blue', label='Trajectory') ax.scatter(trajectory[0, 0], trajectory[0, 1], trajectory[0, 2], color='green', s=60, label='Start') ax.set_title(\"Helical Motion in Magnetic Field\", fontsize=14) ax.set_xlabel(\"X\") ax.set_ylabel(\"Y\") ax.set_zlabel(\"Z\") ax.grid(True) ax.legend() ax.view_init(elev=25, azim=60) plt.tight_layout() plt.show() This code simulates the motion of a charged particle in a uniform magnetic field and visualizes its trajectory. The plot will show how the particle moves in a circular path due to the Lorentz force.","title":"Problem 1"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#simulating-the-effects-of-the-lorentz-force","text":"","title":"Simulating the Effects of the Lorentz Force"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#motivation","text":"The Lorentz force, expressed as: \\[ \\mathbf{F} = q (\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B}) \\] governs the motion of charged particles in electric and magnetic fields. It is foundational in fields like plasma physics, particle accelerators, and astrophysics. By focusing on simulations, we can explore the practical applications and visualize the complex trajectories that arise due to this force.","title":"Motivation:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#task","text":"Exploration of Applications : Identify systems where the Lorentz force plays a key role (e.g., particle accelerators, mass spectrometers, plasma confinement). Discuss the relevance of electric ( \\(\\mathbf{E}\\) ) and magnetic ( \\(\\mathbf{B}\\) ) fields in controlling the motion of charged particles. Simulating Particle Motion : Implement a simulation to compute and visualize the trajectory of a charged particle under: A uniform magnetic field. Combined uniform electric and magnetic fields. Crossed electric and magnetic fields. Simulate the particle\u2019s circular, helical, or drift motion based on initial conditions and field configurations. Parameter Exploration : Allow variations in: Field strengths ( \\(E\\) , \\(B\\) ). Initial particle velocity ( \\(v_0\\) ). Charge and mass of the particle ( \\(q\\) , \\(m\\) ). Observe how these parameters influence the trajectory. Visualization : Create clear, labeled plots showing the particle\u2019s path in 2D and 3D for different scenarios. Highlight physical phenomena such as the Larmor radius and drift velocity.","title":"Task:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#formulas","text":"The Lorentz force equation is given by: \\[ \\mathbf{F} = q (\\mathbf{E} + \\mathbf{v} \\times \\mathbf{B}) \\] Where: \\(\\mathbf{F}\\) is the force acting on the charged particle. \\(q\\) is the charge of the particle. \\(\\mathbf{E}\\) is the electric field. \\(\\mathbf{v}\\) is the velocity of the particle. \\(\\mathbf{B}\\) is the magnetic field. \\(\\times\\) represents the cross product between velocity and the magnetic field. For a particle moving in a uniform magnetic field, its trajectory can be described by circular motion, and the radius of this motion (Larmor radius) is given by: \\[ r = \\frac{mv_{\\perp}}{qB} \\] Where: \\(m\\) is the mass of the particle. \\(v_{\\perp}\\) is the component of the velocity perpendicular to the magnetic field. \\(q\\) is the charge of the particle. \\(B\\) is the magnetic field strength.","title":"Formulas:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#visualization-of-particle-motion","text":"Below is a Python simulation to visualize the particle's trajectory under the influence of a magnetic field.","title":"Visualization of Particle Motion:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#python-code","text":"import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # ----------------------- # \u2699\ufe0f Parameters # ----------------------- q = 1.0 # Charge m = 1.0 # Mass B = np.array([0, 0, 1.0]) # Magnetic field along z-axis E = np.array([0.0, 0.0, 0.0]) # No electric field r = np.array([0.0, 0.0, 0.0]) # Initial position v = np.array([1.0, 0.0, 2.0]) # Initial velocity (x: circular, z: helical) dt = 0.01 T = 10 steps = int(T / dt) # ----------------------- # \ud83d\udd01 Lorentz Force # ----------------------- def lorentz_force(v, r, q, m, E, B): return (q / m) * (E + np.cross(v, B)) # ----------------------- # \ud83e\uddee Simulate # ----------------------- trajectory = [] for _ in range(steps): trajectory.append(r.copy()) a = lorentz_force(v, r, q, m, E, B) v += a * dt r += v * dt trajectory = np.array(trajectory) # ----------------------- # \ud83d\udcca 3D Plot # ----------------------- fig = plt.figure(figsize=(10, 7)) ax = fig.add_subplot(111, projection='3d') ax.plot(trajectory[:, 0], trajectory[:, 1], trajectory[:, 2], color='blue', label='Trajectory') ax.scatter(trajectory[0, 0], trajectory[0, 1], trajectory[0, 2], color='green', s=60, label='Start') ax.set_title(\"Helical Motion in Magnetic Field\", fontsize=14) ax.set_xlabel(\"X\") ax.set_ylabel(\"Y\") ax.set_zlabel(\"Z\") ax.grid(True) ax.legend() ax.view_init(elev=25, azim=60) plt.tight_layout() plt.show()","title":"Python Code:"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#_1","text":"This code simulates the motion of a charged particle in a uniform magnetic field and visualizes its trajectory. The plot will show how the particle moves in a circular path due to the Lorentz force.","title":""},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1 \u26a1 Equivalent Resistance Made Stupid Simple \u26a1 (No physics jargon, just straight-up clarity with emoji power!) \ud83c\udfaf Why Bother With This? \ud83d\udd0c Circuits get messy \u2013 too many resistors = headache. \ud83e\udde0 Graph theory turns chaos into order (like magic). \ud83d\udcbb Computers love this method \u2013 great for automation. \ud83d\udee0\ufe0f Tools You Need Graph Theory Basics \ud83d\udfe2 Nodes = Connection points (where wires meet). \ud83d\udd35 Edges = Resistors (with resistance values). Two Golden Rules # \u26a1 Resistance Rules for Normal People \u26a1 \ud83d\udd17 Series (One After Another) \u27a1 Total Resistance = Just Add Them! R_total = R\u2081 + R\u2082 + R\u2083 + ... Example: 2 + 3 + 5 = 10\u03a9 (Like stacking weights \u2013 total gets heavier!) \ud83d\udd04 Parallel (Side by Side) \u27a1 For TWO Resistors: R_total = (R\u2081 \u00d7 R\u2082) / (R\u2081 + R\u2082) Example: Two 4\u03a9 resistors: (4 \u00d7 4) / (4 + 4) = 2\u03a9 (Like two roads \u2013 traffic flows easier!) \u27a1 For THREE+ Resistors: 1. Multiply all: R\u2081 \u00d7 R\u2082 \u00d7 R\u2083 2. Divide by sum of pairs: (R\u2081R\u2082 + R\u2081R\u2083 + R\u2082R\u2083) Example: Three 2\u03a9 resistors: (2\u00d72\u00d72) / (4 + 4 + 4) = 8/12 \u2248 0.67\u03a9 (Yes, parallel reduces resistance \u2013 more paths = easier flow!) \ud83d\udca1 Pro Tips: \u2705 Series: More resistors = Higher total resistance \u2705 Parallel: More resistors = Lower total resistance \u2705 Always convert parallel to two resistors first if possible! \ud83d\udd0d Step-by-Step Simplification 1\ufe0f\u20e3 Find Resistors in Series (Straight-Line Gang) Look for: Resistors connected end-to-end with no splits . Action: Replace them with one big resistor (sum them up). Example: - R\u2081 = 2\u03a9 + R\u2082 = 3\u03a9 \u2192 Total = 5\u03a9 \u2705 2\ufe0f\u20e3 Find Resistors in Parallel (Side-by-Side Squad) Look for: Resistors sharing the same start & end points . Action: Use the parallel formula to merge them. Example: - R\u2081 = 4\u03a9 || R\u2082 = 4\u03a9 \u2192 Total = 2\u03a9 \u2705 3\ufe0f\u20e3 Repeat Until Only One Resistor Remains Keep simplifying series & parallel until you get one final R . \ud83d\udcbb Let\u2019s Code It! (Python Example) (For those who want automation!) import networkx as nx def simplify_circuit(G): while True: # 1. Check if we're done (only 1 resistor left) if G.number_of_edges() == 1: return list(G.edges(data=True))[0][2]['resistance'] # 2. Try simplifying series resistors simplified = False for node in list(G.nodes()): neighbors = list(G.neighbors(node)) if len(neighbors) == 2: # Series candidate R1 = G[node][neighbors[0]]['resistance'] R2 = G[node][neighbors[1]]['resistance'] G.remove_node(node) G.add_edge(neighbors[0], neighbors[1], resistance=R1 + R2) simplified = True break if simplified: continue # 3. Try simplifying parallel resistors for u, v in list(G.edges()): if G.number_of_edges(u, v) > 1: # Parallel resistors total_R = 1 / sum(1 / G[u][v][k]['resistance'] for k in G[u][v]) G.remove_edges_from(list(G.edges(u, v))) G.add_edge(u, v, resistance=total_R) simplified = True break if not simplified: break # Can't simplify further return \"Complex circuit! Need advanced methods.\" # Example usage G = nx.Graph() G.add_edge('A', 'B', resistance=2) G.add_edge('B', 'C', resistance=3) G.add_edge('A', 'C', resistance=6) print(\"Total resistance:\", simplify_circuit(G)) \ud83d\udcca Real-World Examples 1\ufe0f\u20e3 Simple Series Circuit A --[2\u03a9]-- B --[3\u03a9]-- C Total = 2 + 3 = 5\u03a9 2\ufe0f\u20e3 Simple Parallel Circuit A --[4\u03a9]-- B A --[4\u03a9]-- B Total = 2\u03a9 3\ufe0f\u20e3 Mixed Circuit A --[2\u03a9]-- B --[3\u03a9]-- C A --[6\u03a9]-- C Total = 4\u03a9 (after simplification)","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#equivalent-resistance-made-stupid-simple","text":"(No physics jargon, just straight-up clarity with emoji power!)","title":"\u26a1 Equivalent Resistance Made Stupid Simple \u26a1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#why-bother-with-this","text":"\ud83d\udd0c Circuits get messy \u2013 too many resistors = headache. \ud83e\udde0 Graph theory turns chaos into order (like magic). \ud83d\udcbb Computers love this method \u2013 great for automation.","title":"\ud83c\udfaf Why Bother With This?"},{"location":"1%20Physics/5%20Circuits/Problem_1/#tools-you-need","text":"Graph Theory Basics \ud83d\udfe2 Nodes = Connection points (where wires meet). \ud83d\udd35 Edges = Resistors (with resistance values). Two Golden Rules # \u26a1 Resistance Rules for Normal People \u26a1","title":"\ud83d\udee0\ufe0f Tools You Need"},{"location":"1%20Physics/5%20Circuits/Problem_1/#series-one-after-another","text":"\u27a1 Total Resistance = Just Add Them! R_total = R\u2081 + R\u2082 + R\u2083 + ... Example: 2 + 3 + 5 = 10\u03a9 (Like stacking weights \u2013 total gets heavier!)","title":"\ud83d\udd17 Series (One After Another)"},{"location":"1%20Physics/5%20Circuits/Problem_1/#parallel-side-by-side","text":"\u27a1 For TWO Resistors: R_total = (R\u2081 \u00d7 R\u2082) / (R\u2081 + R\u2082) Example: Two 4\u03a9 resistors: (4 \u00d7 4) / (4 + 4) = 2\u03a9 (Like two roads \u2013 traffic flows easier!) \u27a1 For THREE+ Resistors: 1. Multiply all: R\u2081 \u00d7 R\u2082 \u00d7 R\u2083 2. Divide by sum of pairs: (R\u2081R\u2082 + R\u2081R\u2083 + R\u2082R\u2083) Example: Three 2\u03a9 resistors: (2\u00d72\u00d72) / (4 + 4 + 4) = 8/12 \u2248 0.67\u03a9 (Yes, parallel reduces resistance \u2013 more paths = easier flow!)","title":"\ud83d\udd04 Parallel (Side by Side)"},{"location":"1%20Physics/5%20Circuits/Problem_1/#pro-tips","text":"\u2705 Series: More resistors = Higher total resistance \u2705 Parallel: More resistors = Lower total resistance \u2705 Always convert parallel to two resistors first if possible!","title":"\ud83d\udca1 Pro Tips:"},{"location":"1%20Physics/5%20Circuits/Problem_1/#step-by-step-simplification","text":"","title":"\ud83d\udd0d Step-by-Step Simplification"},{"location":"1%20Physics/5%20Circuits/Problem_1/#1-find-resistors-in-series-straight-line-gang","text":"Look for: Resistors connected end-to-end with no splits . Action: Replace them with one big resistor (sum them up). Example: - R\u2081 = 2\u03a9 + R\u2082 = 3\u03a9 \u2192 Total = 5\u03a9 \u2705","title":"1\ufe0f\u20e3 Find Resistors in Series (Straight-Line Gang)"},{"location":"1%20Physics/5%20Circuits/Problem_1/#2-find-resistors-in-parallel-side-by-side-squad","text":"Look for: Resistors sharing the same start & end points . Action: Use the parallel formula to merge them. Example: - R\u2081 = 4\u03a9 || R\u2082 = 4\u03a9 \u2192 Total = 2\u03a9 \u2705","title":"2\ufe0f\u20e3 Find Resistors in Parallel (Side-by-Side Squad)"},{"location":"1%20Physics/5%20Circuits/Problem_1/#3-repeat-until-only-one-resistor-remains","text":"Keep simplifying series & parallel until you get one final R .","title":"3\ufe0f\u20e3 Repeat Until Only One Resistor Remains"},{"location":"1%20Physics/5%20Circuits/Problem_1/#lets-code-it-python-example","text":"(For those who want automation!) import networkx as nx def simplify_circuit(G): while True: # 1. Check if we're done (only 1 resistor left) if G.number_of_edges() == 1: return list(G.edges(data=True))[0][2]['resistance'] # 2. Try simplifying series resistors simplified = False for node in list(G.nodes()): neighbors = list(G.neighbors(node)) if len(neighbors) == 2: # Series candidate R1 = G[node][neighbors[0]]['resistance'] R2 = G[node][neighbors[1]]['resistance'] G.remove_node(node) G.add_edge(neighbors[0], neighbors[1], resistance=R1 + R2) simplified = True break if simplified: continue # 3. Try simplifying parallel resistors for u, v in list(G.edges()): if G.number_of_edges(u, v) > 1: # Parallel resistors total_R = 1 / sum(1 / G[u][v][k]['resistance'] for k in G[u][v]) G.remove_edges_from(list(G.edges(u, v))) G.add_edge(u, v, resistance=total_R) simplified = True break if not simplified: break # Can't simplify further return \"Complex circuit! Need advanced methods.\" # Example usage G = nx.Graph() G.add_edge('A', 'B', resistance=2) G.add_edge('B', 'C', resistance=3) G.add_edge('A', 'C', resistance=6) print(\"Total resistance:\", simplify_circuit(G))","title":"\ud83d\udcbb Let\u2019s Code It! (Python Example)"},{"location":"1%20Physics/5%20Circuits/Problem_1/#real-world-examples","text":"","title":"\ud83d\udcca Real-World Examples"},{"location":"1%20Physics/5%20Circuits/Problem_1/#1-simple-series-circuit","text":"A --[2\u03a9]-- B --[3\u03a9]-- C Total = 2 + 3 = 5\u03a9","title":"1\ufe0f\u20e3 Simple Series Circuit"},{"location":"1%20Physics/5%20Circuits/Problem_1/#2-simple-parallel-circuit","text":"A --[4\u03a9]-- B A --[4\u03a9]-- B Total = 2\u03a9","title":"2\ufe0f\u20e3 Simple Parallel Circuit"},{"location":"1%20Physics/5%20Circuits/Problem_1/#3-mixed-circuit","text":"A --[2\u03a9]-- B --[3\u03a9]-- C A --[6\u03a9]-- C Total = 4\u03a9 (after simplification)","title":"3\ufe0f\u20e3 Mixed Circuit"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"\ud83e\uddea Central Limit Theorem: Simulation & Insights \ud83e\udde0 What\u2019s the CLT? The Central Limit Theorem (CLT) says: If you take many samples of size n from any population, the distribution of their means will tend to look normal , as n gets large \u2014 even if the original population is not normal. import numpy as np import matplotlib.pyplot as plt import seaborn as sns # Settings sns.set(style=\"whitegrid\") np.random.seed(42) pop_size = 100_000 sample_sizes = [10] n_samples = 1000 # Simulation function def simulate_clt(population, title): for size in sample_sizes: sample_means = [np.mean(np.random.choice(population, size=size)) for _ in range(n_samples)] plt.figure(figsize=(8, 4)) sns.histplot(sample_means, kde=True, bins=30, stat=\"density\", color=\"skyblue\") plt.axvline(np.mean(population), color=\"red\", linestyle=\"--\", label=\"True Mean\") plt.title(f\"{title} \u2014 Sample Size {size}\", fontsize=14) plt.xlabel(\"Sample Mean\") plt.ylabel(\"Density\") plt.legend() plt.tight_layout() plt.show() # Run simulations uniform_pop = np.random.uniform(0, 100, size=pop_size) simulate_clt(uniform_pop, \"Uniform Distribution\") exp_pop = np.random.exponential(scale=50, size=pop_size) simulate_clt(exp_pop, \"Exponential Distribution\") binom_pop = np.random.binomial(n=10, p=0.5, size=pop_size) simulate_clt(binom_pop, \"Binomial Distribution\") \ud83d\udd0d What Did We Learn? Even from non-normal distributions like Exponential or Binomial, the sample means become more bell-shaped as sample size grows. The spread of the sample mean shrinks with larger sample sizes \u2014 this is due to reduced standard error. CLT is powerful : it enables normal-based inference in the real world, even if your raw data isn\u2019t normal. \ud83d\udcbc Applications Polling and surveys \u2014 estimate average opinion from small samples. Manufacturing \u2014 control product quality using means from random checks. Finance \u2014 model returns, errors, and risk from sample averages.","title":"\ud83e\uddea Central Limit Theorem: Simulation &amp; Insights"},{"location":"1%20Physics/6%20Statistics/Problem_1/#central-limit-theorem-simulation-insights","text":"","title":"\ud83e\uddea Central Limit Theorem: Simulation &amp; Insights"},{"location":"1%20Physics/6%20Statistics/Problem_1/#whats-the-clt","text":"The Central Limit Theorem (CLT) says: If you take many samples of size n from any population, the distribution of their means will tend to look normal , as n gets large \u2014 even if the original population is not normal. import numpy as np import matplotlib.pyplot as plt import seaborn as sns # Settings sns.set(style=\"whitegrid\") np.random.seed(42) pop_size = 100_000 sample_sizes = [10] n_samples = 1000 # Simulation function def simulate_clt(population, title): for size in sample_sizes: sample_means = [np.mean(np.random.choice(population, size=size)) for _ in range(n_samples)] plt.figure(figsize=(8, 4)) sns.histplot(sample_means, kde=True, bins=30, stat=\"density\", color=\"skyblue\") plt.axvline(np.mean(population), color=\"red\", linestyle=\"--\", label=\"True Mean\") plt.title(f\"{title} \u2014 Sample Size {size}\", fontsize=14) plt.xlabel(\"Sample Mean\") plt.ylabel(\"Density\") plt.legend() plt.tight_layout() plt.show() # Run simulations uniform_pop = np.random.uniform(0, 100, size=pop_size) simulate_clt(uniform_pop, \"Uniform Distribution\") exp_pop = np.random.exponential(scale=50, size=pop_size) simulate_clt(exp_pop, \"Exponential Distribution\") binom_pop = np.random.binomial(n=10, p=0.5, size=pop_size) simulate_clt(binom_pop, \"Binomial Distribution\")","title":"\ud83e\udde0 What\u2019s the CLT?"},{"location":"1%20Physics/6%20Statistics/Problem_1/#what-did-we-learn","text":"Even from non-normal distributions like Exponential or Binomial, the sample means become more bell-shaped as sample size grows. The spread of the sample mean shrinks with larger sample sizes \u2014 this is due to reduced standard error. CLT is powerful : it enables normal-based inference in the real world, even if your raw data isn\u2019t normal.","title":"\ud83d\udd0d What Did We Learn?"},{"location":"1%20Physics/6%20Statistics/Problem_1/#applications","text":"Polling and surveys \u2014 estimate average opinion from small samples. Manufacturing \u2014 control product quality using means from random checks. Finance \u2014 model returns, errors, and risk from sample averages.","title":"\ud83d\udcbc Applications"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Estimating \u03c0 using Monte Carlo Methods with: \ud83d\udd35 Part 1 : Circle-Based Simulation \ud83e\udea1 Part 2 : Buffon\u2019s Needle \ud83d\udcca Visuals, \u2705 Explanations, \ud83d\udcc8 Analysis \ud83c\udfaf Estimating \u03c0 with Monte Carlo Methods \ud83c\udf70 Part 1: Estimating \u03c0 Using a Circle \ud83e\udde0 Idea: Draw a square (side = 2) around a unit circle (radius = 1). Random points fall randomly inside the square. Count how many fall inside the circle . Since area of circle = \u03c0r\u00b2 = \u03c0 and area of square = 4, \\(\\pi \\approx 4 \\cdot \\left(\\frac{\\text{points in circle}}{\\text{total points}}\\right)\\) \u2699\ufe0f Code import numpy as np import matplotlib.pyplot as plt # Parameters np.random.seed(42) total_points = 10000 # Generate random (x, y) in square [-1, 1] x [-1, 1] x = np.random.uniform(-1, 1, total_points) y = np.random.uniform(-1, 1, total_points) # Distance from origin dist = x**2 + y**2 # Points inside circle inside = dist <= 1 pi_estimate = 4 * np.sum(inside) / total_points # Plot plt.figure(figsize=(6, 6)) plt.scatter(x[inside], y[inside], color=\"skyblue\", s=1, label=\"Inside Circle\") plt.scatter(x[~inside], y[~inside], color=\"lightcoral\", s=1, label=\"Outside Circle\") plt.title(f\"Monte Carlo \u03c0 Estimate: {pi_estimate:.5f}\") plt.xlabel(\"x\") plt.ylabel(\"y\") plt.legend() plt.axis(\"equal\") plt.grid(True) plt.show() \ud83d\udcc8 Convergence Check (Circle Method) trials = [100, 500, 1000, 5000, 10000, 50000] estimates = [] for N in trials: x = np.random.uniform(-1, 1, N) y = np.random.uniform(-1, 1, N) inside = x**2 + y**2 <= 1 estimates.append(4 * np.sum(inside) / N) # Plot convergence plt.plot(trials, estimates, marker='o') plt.axhline(np.pi, color='red', linestyle='--', label='\u03c0 (True Value)') plt.title(\"Convergence of \u03c0 Estimate (Circle Method)\") plt.xlabel(\"Number of Points\") plt.ylabel(\"Estimated \u03c0\") plt.legend() plt.grid(True) plt.show() \ud83e\udea1 Part 2: Estimating \u03c0 Using Buffon\u2019s Needle \ud83e\udde0 Idea: Drop a needle of length L \u2264 d between parallel lines d units apart. Probability of crossing a line is: \\(P = \\frac{2L}{\\pi d}\\) Rearranged: \\(\\pi \\approx \\frac{2L \\cdot N}{d \\cdot H}\\) where: N = total drops H = hits (crossing a line) \u2699\ufe0f Code import numpy as np import matplotlib.pyplot as plt np.random.seed(42) # --- Part 1: Circle Monte Carlo --- def estimate_pi_circle(total_points): x = np.random.uniform(-1, 1, total_points) y = np.random.uniform(-1, 1, total_points) inside = x**2 + y**2 <= 1 pi_estimate = 4 * np.sum(inside) / total_points return pi_estimate, x, y, inside # Plot circle method points and estimate total_points = 10000 pi_estimate, x, y, inside = estimate_pi_circle(total_points) plt.figure(figsize=(6,6)) plt.scatter(x[inside], y[inside], color=\"skyblue\", s=1, label=\"Inside Circle\") plt.scatter(x[~inside], y[~inside], color=\"lightcoral\", s=1, label=\"Outside Circle\") plt.title(f\"Monte Carlo \u03c0 Estimate (Circle): {pi_estimate:.5f}\") plt.xlabel(\"x\") plt.ylabel(\"y\") plt.legend() plt.axis(\"equal\") plt.grid(True) plt.show() # Convergence plot for circle method trials = [100, 500, 1000, 5000, 10000, 50000] estimates_circle = [] for N in trials: pi_val, _, _, _ = estimate_pi_circle(N) estimates_circle.append(pi_val) plt.plot(trials, estimates_circle, marker='o', label='Circle Estimate') plt.axhline(np.pi, color='red', linestyle='--', label='\u03c0 (True Value)') plt.title(\"Convergence of \u03c0 Estimate (Circle Method)\") plt.xlabel(\"Number of Points\") plt.ylabel(\"Estimated \u03c0\") plt.legend() plt.grid(True) plt.show() # --- Part 2: Buffon's Needle --- def estimate_pi_buffon(L, d, N): theta = np.random.uniform(0, np.pi/2, N) x_center = np.random.uniform(0, d/2, N) hits = x_center <= (L/2)*np.sin(theta) H = np.sum(hits) if H == 0: return np.nan return (2 * L * N) / (d * H) L = 1 # needle length d = 2 # distance between lines N = 10000 pi_buffon = estimate_pi_buffon(L, d, N) print(f\"Buffon's Needle \u03c0 Estimate: {pi_buffon:.5f}\") # Convergence plot for Buffon's Needle estimates_buffon = [] for N in trials: pi_val = estimate_pi_buffon(L, d, N) estimates_buffon.append(pi_val) plt.plot(trials, estimates_buffon, marker='o', label=\"Buffon's Needle Estimate\") plt.axhline(np.pi, color='red', linestyle='--', label='\u03c0 (True Value)') plt.title(\"Convergence of \u03c0 Estimate (Buffon's Needle)\") plt.xlabel(\"Number of Needle Drops\") plt.ylabel(\"Estimated \u03c0\") plt.legend() plt.grid(True) plt.show() \ud83d\udcac Observations The circle method converges more quickly and visually. Buffon\u2019s needle is less efficient \u2014 more randomness, slower convergence. Both methods show how randomness + geometry = powerful math .","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#estimating-with-monte-carlo-methods","text":"","title":"\ud83c\udfaf Estimating \u03c0 with Monte Carlo Methods"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-1-estimating-using-a-circle","text":"","title":"\ud83c\udf70 Part 1: Estimating \u03c0 Using a Circle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#idea","text":"Draw a square (side = 2) around a unit circle (radius = 1). Random points fall randomly inside the square. Count how many fall inside the circle . Since area of circle = \u03c0r\u00b2 = \u03c0 and area of square = 4, \\(\\pi \\approx 4 \\cdot \\left(\\frac{\\text{points in circle}}{\\text{total points}}\\right)\\)","title":"\ud83e\udde0 Idea:"},{"location":"1%20Physics/6%20Statistics/Problem_2/#code","text":"import numpy as np import matplotlib.pyplot as plt # Parameters np.random.seed(42) total_points = 10000 # Generate random (x, y) in square [-1, 1] x [-1, 1] x = np.random.uniform(-1, 1, total_points) y = np.random.uniform(-1, 1, total_points) # Distance from origin dist = x**2 + y**2 # Points inside circle inside = dist <= 1 pi_estimate = 4 * np.sum(inside) / total_points # Plot plt.figure(figsize=(6, 6)) plt.scatter(x[inside], y[inside], color=\"skyblue\", s=1, label=\"Inside Circle\") plt.scatter(x[~inside], y[~inside], color=\"lightcoral\", s=1, label=\"Outside Circle\") plt.title(f\"Monte Carlo \u03c0 Estimate: {pi_estimate:.5f}\") plt.xlabel(\"x\") plt.ylabel(\"y\") plt.legend() plt.axis(\"equal\") plt.grid(True) plt.show()","title":"\u2699\ufe0f Code"},{"location":"1%20Physics/6%20Statistics/Problem_2/#convergence-check-circle-method","text":"trials = [100, 500, 1000, 5000, 10000, 50000] estimates = [] for N in trials: x = np.random.uniform(-1, 1, N) y = np.random.uniform(-1, 1, N) inside = x**2 + y**2 <= 1 estimates.append(4 * np.sum(inside) / N) # Plot convergence plt.plot(trials, estimates, marker='o') plt.axhline(np.pi, color='red', linestyle='--', label='\u03c0 (True Value)') plt.title(\"Convergence of \u03c0 Estimate (Circle Method)\") plt.xlabel(\"Number of Points\") plt.ylabel(\"Estimated \u03c0\") plt.legend() plt.grid(True) plt.show()","title":"\ud83d\udcc8 Convergence Check (Circle Method)"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-2-estimating-using-buffons-needle","text":"","title":"\ud83e\udea1 Part 2: Estimating \u03c0 Using Buffon\u2019s Needle"},{"location":"1%20Physics/6%20Statistics/Problem_2/#idea_1","text":"Drop a needle of length L \u2264 d between parallel lines d units apart. Probability of crossing a line is: \\(P = \\frac{2L}{\\pi d}\\) Rearranged: \\(\\pi \\approx \\frac{2L \\cdot N}{d \\cdot H}\\) where: N = total drops H = hits (crossing a line)","title":"\ud83e\udde0 Idea:"},{"location":"1%20Physics/6%20Statistics/Problem_2/#code_1","text":"import numpy as np import matplotlib.pyplot as plt np.random.seed(42) # --- Part 1: Circle Monte Carlo --- def estimate_pi_circle(total_points): x = np.random.uniform(-1, 1, total_points) y = np.random.uniform(-1, 1, total_points) inside = x**2 + y**2 <= 1 pi_estimate = 4 * np.sum(inside) / total_points return pi_estimate, x, y, inside # Plot circle method points and estimate total_points = 10000 pi_estimate, x, y, inside = estimate_pi_circle(total_points) plt.figure(figsize=(6,6)) plt.scatter(x[inside], y[inside], color=\"skyblue\", s=1, label=\"Inside Circle\") plt.scatter(x[~inside], y[~inside], color=\"lightcoral\", s=1, label=\"Outside Circle\") plt.title(f\"Monte Carlo \u03c0 Estimate (Circle): {pi_estimate:.5f}\") plt.xlabel(\"x\") plt.ylabel(\"y\") plt.legend() plt.axis(\"equal\") plt.grid(True) plt.show() # Convergence plot for circle method trials = [100, 500, 1000, 5000, 10000, 50000] estimates_circle = [] for N in trials: pi_val, _, _, _ = estimate_pi_circle(N) estimates_circle.append(pi_val) plt.plot(trials, estimates_circle, marker='o', label='Circle Estimate') plt.axhline(np.pi, color='red', linestyle='--', label='\u03c0 (True Value)') plt.title(\"Convergence of \u03c0 Estimate (Circle Method)\") plt.xlabel(\"Number of Points\") plt.ylabel(\"Estimated \u03c0\") plt.legend() plt.grid(True) plt.show() # --- Part 2: Buffon's Needle --- def estimate_pi_buffon(L, d, N): theta = np.random.uniform(0, np.pi/2, N) x_center = np.random.uniform(0, d/2, N) hits = x_center <= (L/2)*np.sin(theta) H = np.sum(hits) if H == 0: return np.nan return (2 * L * N) / (d * H) L = 1 # needle length d = 2 # distance between lines N = 10000 pi_buffon = estimate_pi_buffon(L, d, N) print(f\"Buffon's Needle \u03c0 Estimate: {pi_buffon:.5f}\") # Convergence plot for Buffon's Needle estimates_buffon = [] for N in trials: pi_val = estimate_pi_buffon(L, d, N) estimates_buffon.append(pi_val) plt.plot(trials, estimates_buffon, marker='o', label=\"Buffon's Needle Estimate\") plt.axhline(np.pi, color='red', linestyle='--', label='\u03c0 (True Value)') plt.title(\"Convergence of \u03c0 Estimate (Buffon's Needle)\") plt.xlabel(\"Number of Needle Drops\") plt.ylabel(\"Estimated \u03c0\") plt.legend() plt.grid(True) plt.show()","title":"\u2699\ufe0f Code"},{"location":"1%20Physics/6%20Statistics/Problem_2/#observations","text":"The circle method converges more quickly and visually. Buffon\u2019s needle is less efficient \u2014 more randomness, slower convergence. Both methods show how randomness + geometry = powerful math .","title":"\ud83d\udcac Observations"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Measuring Earth's Gravitational Acceleration with a Pendulum Motivation The acceleration due to gravity, \\(g\\) , is a fundamental constant in physics. Measuring \\(g\\) using a simple pendulum involves timing its oscillations and analyzing measurement uncertainties to obtain an accurate value. Procedure Measure the pendulum length \\(L\\) with known resolution \\(\\Delta L\\) . Perform 10 trials timing 10 full oscillations each. Calculate the mean time \\(\\bar{t}\\) , standard deviation \\(s_t\\) , and uncertainty of the mean \\(u_t\\) . Compute the period \\(T = \\bar{t} / 10\\) . Calculate \\(g\\) using \\(g = \\frac{4 \\pi^2 L}{T^2}\\) . Propagate uncertainties to find uncertainty in \\(g\\) , \\(u_g\\) . Formulas \\[ T = \\frac{\\bar{t}}{10} \\] \\[ g = \\frac{4 \\pi^2 L}{T^2} \\] \\[ u_t = \\frac{s_t}{\\sqrt{n}}, \\quad u_L = \\frac{\\Delta L}{2}, \\quad u_T = \\frac{u_t}{10} \\] \\[ u_g = g \\times \\sqrt{\\left(\\frac{u_L}{L}\\right)^2 + \\left(2 \\frac{u_T}{T}\\right)^2} \\] Python Implementation with Visualizations import numpy as np import matplotlib.pyplot as plt # Input Data L = 1.00 # Pendulum length (m) resolution_L = 0.01 # Measurement resolution (m) u_L = resolution_L / 2 # Uncertainty in length t_measurements = np.array([ 20.1, 19.9, 20.3, 20.2, 20.0, 19.8, 20.4, 20.1, 19.9, 20.2 ]) # Time for 10 oscillations (s) n = len(t_measurements) mean_t = np.mean(t_measurements) std_t = np.std(t_measurements, ddof=1) u_t = std_t / np.sqrt(n) # Calculate Period and Uncertainty T = mean_t / 10 u_T = u_t / 10 # Calculate g and its uncertainty g = (4 * np.pi**2 * L) / (T**2) u_g = g * np.sqrt((u_L / L)**2 + (2 * u_T / T)**2) # Print Results print(f\"Length (L): {L:.3f} \u00b1 {u_L:.3f} m\") print(f\"Mean time (t): {mean_t:.3f} \u00b1 {u_t:.3f} s\") print(f\"Period (T): {T:.3f} \u00b1 {u_T:.3f} s\") print(f\"Calculated g: {g:.3f} \u00b1 {u_g:.3f} m/s\u00b2\") print(f\"Standard g: 9.80665 m/s\u00b2\") # Plot 1: Time measurements with error bars plt.figure(figsize=(8,4)) plt.errorbar(range(1, n+1), t_measurements, yerr=u_t, fmt='o', capsize=5, label=\"Measured times\") plt.hlines(mean_t, 1, n, colors='r', label=f\"Mean time: {mean_t:.3f} s\") plt.title(\"Time for 10 oscillations measurements\") plt.xlabel(\"Trial number\") plt.ylabel(\"Time (s)\") plt.legend() plt.grid(True) plt.show() # Plot 2: Histogram of time measurements plt.figure(figsize=(6,4)) plt.hist(t_measurements, bins=5, color='skyblue', edgecolor='black') plt.axvline(mean_t, color='r', linestyle='--', label=f\"Mean = {mean_t:.3f} s\") plt.title(\"Histogram of time measurements\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Frequency\") plt.legend() plt.grid(True) plt.show() # Plot 3: Calculated g with uncertainty plt.figure(figsize=(6,4)) plt.bar(1, g, yerr=u_g, capsize=10, color='lightgreen', label=\"Measured g\") plt.hlines(9.80665, 0.5, 1.5, colors='r', linestyles='--', label=\"Standard g\") plt.xlim(0.5, 1.5) plt.xticks([]) plt.ylabel(\"g (m/s\u00b2)\") plt.title(\"Measured gravitational acceleration with uncertainty\") plt.legend() plt.grid(True) plt.show() Tabulated Data Summary Quantity Value Uncertainty Unit Pendulum length \\(L\\) 1.000 \u00b1 0.005 m Times for 10 oscillations \\(t_i\\) 20.1, 19.9, ..., 20.2 \u2014 s Mean time \\(\\bar{t}\\) 20.09 \u00b1 0.07 s Period \\(T\\) 2.009 \u00b1 0.007 s Gravitational acceleration \\(g\\) 9.75 \u00b1 0.07 m/s\u00b2 Standard gravitational acceleration \\(g_0\\) 9.80665 \u2014 m/s\u00b2 Discussion The measurement resolution impacts the length uncertainty \\(u_L\\) . Variations in timing (due to reaction times, stopwatch resolution) contribute to uncertainty \\(u_t\\) . The simple pendulum approximation holds best for small angles (<15\u00b0). Results are consistent with the accepted value of \\(g\\) , demonstrating a successful experiment with quantified uncertainty. Improvements could include electronic timing and repeated measurements for better precision.","title":"Measuring Earth's Gravitational Acceleration with a Pendulum"},{"location":"1%20Physics/7%20Measurements/Problem_1/#measuring-earths-gravitational-acceleration-with-a-pendulum","text":"","title":"Measuring Earth's Gravitational Acceleration with a Pendulum"},{"location":"1%20Physics/7%20Measurements/Problem_1/#motivation","text":"The acceleration due to gravity, \\(g\\) , is a fundamental constant in physics. Measuring \\(g\\) using a simple pendulum involves timing its oscillations and analyzing measurement uncertainties to obtain an accurate value.","title":"Motivation"},{"location":"1%20Physics/7%20Measurements/Problem_1/#procedure","text":"Measure the pendulum length \\(L\\) with known resolution \\(\\Delta L\\) . Perform 10 trials timing 10 full oscillations each. Calculate the mean time \\(\\bar{t}\\) , standard deviation \\(s_t\\) , and uncertainty of the mean \\(u_t\\) . Compute the period \\(T = \\bar{t} / 10\\) . Calculate \\(g\\) using \\(g = \\frac{4 \\pi^2 L}{T^2}\\) . Propagate uncertainties to find uncertainty in \\(g\\) , \\(u_g\\) .","title":"Procedure"},{"location":"1%20Physics/7%20Measurements/Problem_1/#formulas","text":"\\[ T = \\frac{\\bar{t}}{10} \\] \\[ g = \\frac{4 \\pi^2 L}{T^2} \\] \\[ u_t = \\frac{s_t}{\\sqrt{n}}, \\quad u_L = \\frac{\\Delta L}{2}, \\quad u_T = \\frac{u_t}{10} \\] \\[ u_g = g \\times \\sqrt{\\left(\\frac{u_L}{L}\\right)^2 + \\left(2 \\frac{u_T}{T}\\right)^2} \\]","title":"Formulas"},{"location":"1%20Physics/7%20Measurements/Problem_1/#python-implementation-with-visualizations","text":"import numpy as np import matplotlib.pyplot as plt # Input Data L = 1.00 # Pendulum length (m) resolution_L = 0.01 # Measurement resolution (m) u_L = resolution_L / 2 # Uncertainty in length t_measurements = np.array([ 20.1, 19.9, 20.3, 20.2, 20.0, 19.8, 20.4, 20.1, 19.9, 20.2 ]) # Time for 10 oscillations (s) n = len(t_measurements) mean_t = np.mean(t_measurements) std_t = np.std(t_measurements, ddof=1) u_t = std_t / np.sqrt(n) # Calculate Period and Uncertainty T = mean_t / 10 u_T = u_t / 10 # Calculate g and its uncertainty g = (4 * np.pi**2 * L) / (T**2) u_g = g * np.sqrt((u_L / L)**2 + (2 * u_T / T)**2) # Print Results print(f\"Length (L): {L:.3f} \u00b1 {u_L:.3f} m\") print(f\"Mean time (t): {mean_t:.3f} \u00b1 {u_t:.3f} s\") print(f\"Period (T): {T:.3f} \u00b1 {u_T:.3f} s\") print(f\"Calculated g: {g:.3f} \u00b1 {u_g:.3f} m/s\u00b2\") print(f\"Standard g: 9.80665 m/s\u00b2\") # Plot 1: Time measurements with error bars plt.figure(figsize=(8,4)) plt.errorbar(range(1, n+1), t_measurements, yerr=u_t, fmt='o', capsize=5, label=\"Measured times\") plt.hlines(mean_t, 1, n, colors='r', label=f\"Mean time: {mean_t:.3f} s\") plt.title(\"Time for 10 oscillations measurements\") plt.xlabel(\"Trial number\") plt.ylabel(\"Time (s)\") plt.legend() plt.grid(True) plt.show() # Plot 2: Histogram of time measurements plt.figure(figsize=(6,4)) plt.hist(t_measurements, bins=5, color='skyblue', edgecolor='black') plt.axvline(mean_t, color='r', linestyle='--', label=f\"Mean = {mean_t:.3f} s\") plt.title(\"Histogram of time measurements\") plt.xlabel(\"Time (s)\") plt.ylabel(\"Frequency\") plt.legend() plt.grid(True) plt.show() # Plot 3: Calculated g with uncertainty plt.figure(figsize=(6,4)) plt.bar(1, g, yerr=u_g, capsize=10, color='lightgreen', label=\"Measured g\") plt.hlines(9.80665, 0.5, 1.5, colors='r', linestyles='--', label=\"Standard g\") plt.xlim(0.5, 1.5) plt.xticks([]) plt.ylabel(\"g (m/s\u00b2)\") plt.title(\"Measured gravitational acceleration with uncertainty\") plt.legend() plt.grid(True) plt.show()","title":"Python Implementation with Visualizations"},{"location":"1%20Physics/7%20Measurements/Problem_1/#tabulated-data-summary","text":"Quantity Value Uncertainty Unit Pendulum length \\(L\\) 1.000 \u00b1 0.005 m Times for 10 oscillations \\(t_i\\) 20.1, 19.9, ..., 20.2 \u2014 s Mean time \\(\\bar{t}\\) 20.09 \u00b1 0.07 s Period \\(T\\) 2.009 \u00b1 0.007 s Gravitational acceleration \\(g\\) 9.75 \u00b1 0.07 m/s\u00b2 Standard gravitational acceleration \\(g_0\\) 9.80665 \u2014 m/s\u00b2","title":"Tabulated Data Summary"},{"location":"1%20Physics/7%20Measurements/Problem_1/#discussion","text":"The measurement resolution impacts the length uncertainty \\(u_L\\) . Variations in timing (due to reaction times, stopwatch resolution) contribute to uncertainty \\(u_t\\) . The simple pendulum approximation holds best for small angles (<15\u00b0). Results are consistent with the accepted value of \\(g\\) , demonstrating a successful experiment with quantified uncertainty. Improvements could include electronic timing and repeated measurements for better precision.","title":"Discussion"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}