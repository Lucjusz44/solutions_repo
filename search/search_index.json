{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Technical setup Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft) Useful links Python Miniconda Documentation Google Colab How to use this repository Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW Where can I find the problems? Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#technical-setup","text":"Install Visual Studio Code from here Install folowing extensions in Visual Studio Code: Github Repositories (GitHub, Inc.) GitHub Copilot (GitHub Copilot) GitHub Actions (GitHub, Inc.) Python (Microsoft)","title":"Technical setup"},{"location":"#useful-links","text":"Python Miniconda Documentation Google Colab","title":"Useful links"},{"location":"#how-to-use-this-repository","text":"Below are the steps you need to follow: Create a GitHub account if you don\u2019t have one. Fork this repository to your account. Enable the Issues tab: Go to the Settings tab and check the Issues option. Add your professor as a collaborator: Go to the Settings tab and add their GitHub username in the Collaborators section. Install python: Download Source Code & WWW GitHub repo WWW","title":"How to use this repository"},{"location":"#where-can-i-find-the-problems","text":"Please visit the Mathematics Physics Lectures website. Physics Mathematics Discret Mathematics","title":"Where can I find the problems?"},{"location":"1%20Physics/1%20Mechanics/Problem_1/","text":"Problem 1 \ud83d\udccc Mechanics: Investigating the Range as a Function of the Angle of Projection \ud83c\udff9 Motivation Projectile motion appears simple, yet it encapsulates deep physical principles. By analyzing how the range of a projectile varies with its launch angle, we uncover fascinating relationships governed by linear and quadratic equations. These equations have broad applications, from sports (e.g., the trajectory of a soccer ball) to engineering (e.g., missile launch dynamics). \u2696 1. Theoretical Foundation \ud83d\udcdc Equations of Motion A projectile launched with an initial velocity \\( v_0 \\) at an angle \\( \\theta \\) follows a parabolic trajectory under the influence of gravity. We derive its motion using Newton's laws. \ud83d\udd39 Horizontal Motion Since there is no acceleration in the horizontal direction (assuming no air resistance), the velocity remains constant: \\[ x(t) = v_0 \\cos\\theta \\cdot t \\] \ud83d\udd39 Vertical Motion The vertical motion is governed by constant acceleration due to gravity \\( g \\) : \\[ y(t) = v_0 \\sin\\theta \\cdot t - \\frac{1}{2} g t^2 \\] The projectile reaches the ground when \\( y = 0 \\) , solving for \\( t \\) : \\[ t_f = \\frac{2 v_0 \\sin\\theta}{g} \\] This is the total time of flight . \ud83d\udccf 2. Analysis of the Range The range \\( R \\) is the horizontal distance covered by the projectile when it lands: \\[ R = x(t_f) = v_0 \\cos\\theta \\cdot \\frac{2 v_0 \\sin\\theta}{g} \\] Using the identity \\( 2\\sin\\theta\\cos\\theta = \\sin 2\\theta \\) , we get: \\[ R = \\frac{v_0^2}{g} \\sin 2\\theta \\] \ud83d\udccc Key Observations: Maximum Range: The range is maximized when \\( \\sin 2\\theta = 1 \\) , i.e., \\( 2\\theta = 90^\\circ \\) \u2192 \\( \\theta = 45^\\circ \\) . Symmetry: The function \\( R(\\theta) \\) is symmetric around \\( 45^\\circ \\) , meaning \\( R(\\theta) = R(90^\\circ - \\theta) \\) . Effect of Initial Velocity: Since \\( R \\propto v_0^2 \\) , doubling \\( v_0 \\) quadruples the range. Effect of Gravity: Since \\( R \\propto \\frac{1}{g} \\) , projectiles travel farther on planets with lower gravity (e.g., the Moon). \ud83c\udf0e 3. Practical Applications Sports: Soccer: Kicking a ball at \\( 45^\\circ \\) for maximum distance. Basketball: Analyzing the optimal shooting angle. Engineering & Ballistics: Missile trajectories and range optimization. Water fountains and fluid mechanics. Astrophysics: Moon landings require adjusting launch angles based on gravity. \ud83d\udcbb 4. Implementation (Python Simulation) Below is a Python script to simulate the projectile range as a function of \\( \\theta \\) : import numpy as np import matplotlib.pyplot as plt # Constants v0 = 20 # Initial velocity (m/s) g = 9.81 # Gravity (m/s\u00b2) # Angles from 0 to 90 degrees theta = np.linspace(0, 90, 100) theta_rad = np.radians(theta) # Convert to radians # Compute range for each angle R = (v0**2 / g) * np.sin(2 * theta_rad) # Plot results plt.figure(figsize=(8, 5)) plt.plot(theta, R, label=r'Range $R = \\frac{v_0^2}{g} \\sin 2\\theta$', color='b') plt.axvline(45, linestyle=\"--\", color=\"r\", label=r'Maximum at $\\theta = 45^\\circ$') plt.xlabel(\"Launch Angle (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Projectile Range vs. Launch Angle\") plt.legend() plt.grid() plt.show() \ud83d\udcca 5. Results and Discussion \ud83d\udd39 Graph Interpretation The maximum range occurs at \\( \\theta = 45^\\circ \\) . The function is symmetric about \\( 45^\\circ \\) . Higher \\( v_0 \\) increases range quadratically. \ud83d\udd39 Limitations of the Model Assumes no air resistance . Assumes flat terrain (ignores hills, obstacles). Ignores wind effects , which can alter trajectories. \ud83d\udd39 Enhancements Add air drag to create more realistic simulations. Consider launches from elevated platforms (e.g., artillery firing from a hill). \ud83c\udfaf Conclusion This study shows how the range of a projectile depends on launch angle, initial velocity, and gravity. The ideal case follows the classic \\( R = \\frac{v_0^2}{g} \\sin 2\\theta \\) relation, peaking at \\( 45^\\circ \\) . However, real-world factors like air resistance modify this behavior, making computational modeling essential for accurate predictions. Would you like me to extend the model with air resistance or non-flat terrain? \ud83d\ude80","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#mechanics-investigating-the-range-as-a-function-of-the-angle-of-projection","text":"","title":"\ud83d\udccc Mechanics: Investigating the Range as a Function of the Angle of Projection"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#motivation","text":"Projectile motion appears simple, yet it encapsulates deep physical principles. By analyzing how the range of a projectile varies with its launch angle, we uncover fascinating relationships governed by linear and quadratic equations. These equations have broad applications, from sports (e.g., the trajectory of a soccer ball) to engineering (e.g., missile launch dynamics).","title":"\ud83c\udff9 Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#1-theoretical-foundation","text":"","title":"\u2696 1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#equations-of-motion","text":"A projectile launched with an initial velocity \\( v_0 \\) at an angle \\( \\theta \\) follows a parabolic trajectory under the influence of gravity. We derive its motion using Newton's laws.","title":"\ud83d\udcdc Equations of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#horizontal-motion","text":"Since there is no acceleration in the horizontal direction (assuming no air resistance), the velocity remains constant: \\[ x(t) = v_0 \\cos\\theta \\cdot t \\]","title":"\ud83d\udd39 Horizontal Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#vertical-motion","text":"The vertical motion is governed by constant acceleration due to gravity \\( g \\) : \\[ y(t) = v_0 \\sin\\theta \\cdot t - \\frac{1}{2} g t^2 \\] The projectile reaches the ground when \\( y = 0 \\) , solving for \\( t \\) : \\[ t_f = \\frac{2 v_0 \\sin\\theta}{g} \\] This is the total time of flight .","title":"\ud83d\udd39 Vertical Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#2-analysis-of-the-range","text":"The range \\( R \\) is the horizontal distance covered by the projectile when it lands: \\[ R = x(t_f) = v_0 \\cos\\theta \\cdot \\frac{2 v_0 \\sin\\theta}{g} \\] Using the identity \\( 2\\sin\\theta\\cos\\theta = \\sin 2\\theta \\) , we get: \\[ R = \\frac{v_0^2}{g} \\sin 2\\theta \\]","title":"\ud83d\udccf 2. Analysis of the Range"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#key-observations","text":"Maximum Range: The range is maximized when \\( \\sin 2\\theta = 1 \\) , i.e., \\( 2\\theta = 90^\\circ \\) \u2192 \\( \\theta = 45^\\circ \\) . Symmetry: The function \\( R(\\theta) \\) is symmetric around \\( 45^\\circ \\) , meaning \\( R(\\theta) = R(90^\\circ - \\theta) \\) . Effect of Initial Velocity: Since \\( R \\propto v_0^2 \\) , doubling \\( v_0 \\) quadruples the range. Effect of Gravity: Since \\( R \\propto \\frac{1}{g} \\) , projectiles travel farther on planets with lower gravity (e.g., the Moon).","title":"\ud83d\udccc Key Observations:"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#3-practical-applications","text":"Sports: Soccer: Kicking a ball at \\( 45^\\circ \\) for maximum distance. Basketball: Analyzing the optimal shooting angle. Engineering & Ballistics: Missile trajectories and range optimization. Water fountains and fluid mechanics. Astrophysics: Moon landings require adjusting launch angles based on gravity.","title":"\ud83c\udf0e 3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#4-implementation-python-simulation","text":"Below is a Python script to simulate the projectile range as a function of \\( \\theta \\) : import numpy as np import matplotlib.pyplot as plt # Constants v0 = 20 # Initial velocity (m/s) g = 9.81 # Gravity (m/s\u00b2) # Angles from 0 to 90 degrees theta = np.linspace(0, 90, 100) theta_rad = np.radians(theta) # Convert to radians # Compute range for each angle R = (v0**2 / g) * np.sin(2 * theta_rad) # Plot results plt.figure(figsize=(8, 5)) plt.plot(theta, R, label=r'Range $R = \\frac{v_0^2}{g} \\sin 2\\theta$', color='b') plt.axvline(45, linestyle=\"--\", color=\"r\", label=r'Maximum at $\\theta = 45^\\circ$') plt.xlabel(\"Launch Angle (degrees)\") plt.ylabel(\"Range (m)\") plt.title(\"Projectile Range vs. Launch Angle\") plt.legend() plt.grid() plt.show()","title":"\ud83d\udcbb 4. Implementation (Python Simulation)"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#5-results-and-discussion","text":"","title":"\ud83d\udcca 5. Results and Discussion"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#graph-interpretation","text":"The maximum range occurs at \\( \\theta = 45^\\circ \\) . The function is symmetric about \\( 45^\\circ \\) . Higher \\( v_0 \\) increases range quadratically.","title":"\ud83d\udd39 Graph Interpretation"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#limitations-of-the-model","text":"Assumes no air resistance . Assumes flat terrain (ignores hills, obstacles). Ignores wind effects , which can alter trajectories.","title":"\ud83d\udd39 Limitations of the Model"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#enhancements","text":"Add air drag to create more realistic simulations. Consider launches from elevated platforms (e.g., artillery firing from a hill).","title":"\ud83d\udd39 Enhancements"},{"location":"1%20Physics/1%20Mechanics/Problem_1/#conclusion","text":"This study shows how the range of a projectile depends on launch angle, initial velocity, and gravity. The ideal case follows the classic \\( R = \\frac{v_0^2}{g} \\sin 2\\theta \\) relation, peaking at \\( 45^\\circ \\) . However, real-world factors like air resistance modify this behavior, making computational modeling essential for accurate predictions. Would you like me to extend the model with air resistance or non-flat terrain? \ud83d\ude80","title":"\ud83c\udfaf Conclusion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/","text":"Problem 2 \ud83d\udccc Investigating the Dynamics of a Forced Damped Pendulum \ud83c\udfd7 Motivation The forced damped pendulum is a fascinating system that exhibits a range of behaviors, from simple oscillations to chaotic motion. By introducing damping and an external periodic force , we observe a transition from regular periodic motion to resonance, quasiperiodicity, and chaos . This system is crucial for understanding: - Resonance in mechanical systems (e.g., bridges, buildings under periodic stress). - Nonlinear dynamics and chaos theory (e.g., weather patterns, heart rhythms). - Energy harvesting from oscillations. \u2696 1. Theoretical Foundation \ud83d\udcdc Equation of Motion The forced damped pendulum follows the nonlinear differential equation: \\[ \\ddot{\\theta} + \\gamma \\dot{\\theta} + \\omega_0^2 \\sin\\theta = A \\cos(\\omega t) \\] where: - \\( \\theta \\) = angular displacement - \\( \\gamma \\) = damping coefficient - \\( \\omega_0 \\) = natural frequency of the pendulum ( \\( \\omega_0 = \\sqrt{\\frac{g}{L}} \\) ) - \\( A \\) = amplitude of the external driving force - \\( \\omega \\) = driving frequency For small angles ( \\( \\theta \\approx \\sin\\theta \\) ), the equation simplifies to: \\[ \\ddot{\\theta} + \\gamma \\dot{\\theta} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] which resembles the equation of a driven damped harmonic oscillator . \ud83d\udccc Resonance Condition Resonance occurs when the driving frequency \\( \\omega \\) matches the natural frequency \\( \\omega_0 \\) , leading to maximum energy absorption and large oscillations: \\[ \\omega_{\\text{res}} \\approx \\sqrt{\\omega_0^2 - \\frac{\\gamma^2}{4}} \\] At resonance, even small driving forces can produce large oscillations, which is crucial in mechanical engineering and structural safety . \ud83d\udcca 2. Analysis of Dynamics \ud83d\udd39 Effect of Damping ( \\( \\gamma \\) ) Low damping: The pendulum exhibits large oscillations and resonance. High damping: The system stabilizes quickly with reduced oscillations. \ud83d\udd39 Effect of Driving Amplitude ( \\( A \\) ) Low amplitude: The pendulum undergoes periodic motion. High amplitude: The system transitions into chaotic motion for certain frequencies. \ud83d\udd39 Effect of Driving Frequency ( \\( \\omega \\) ) When \\( \\omega \\approx \\omega_0 \\) , resonance occurs. When \\( \\omega \\) is far from \\( \\omega_0 \\) , the response is weak. Nonlinear behavior emerges at certain parameter values, leading to chaos. \ud83c\udf0d 3. Practical Applications Engineering & Structural Dynamics Bridges & Skyscrapers: Understanding how periodic forces (e.g., wind, earthquakes) affect large structures. Vibration Isolation: Designing materials that minimize resonance effects. Energy Harvesting Pendulum-based generators: Extracting energy from periodic motion. Ocean wave energy devices. Chaos Theory & Climate Models Weather prediction models involve nonlinear oscillatory behaviors similar to the forced pendulum. \ud83d\udcbb 4. Implementation (Python Simulation) Below is a Python script that simulates the motion of a forced damped pendulum using numerical integration (Runge-Kutta method) . \ud83d\udccc Step 1: Install Required Libraries Before running the code, install NumPy and Matplotlib if needed: pip install numpy matplotlib scipy \ud83d\udccc Step 2: Python Code for Simulation import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define system parameters g = 9.81 # Gravity (m/s\u00b2) L = 1.0 # Length of pendulum (m) gamma = 0.2 # Damping coefficient A = 1.5 # Driving amplitude omega = 2.0 # Driving frequency # Define natural frequency omega_0 = np.sqrt(g / L) # Define the equations of motion def forced_damped_pendulum(t, y): theta, omega_t = y dtheta_dt = omega_t domega_dt = -gamma * omega_t - omega_0**2 * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Initial conditions: theta = 0.2 rad, omega = 0 rad/s y0 = [0.2, 0] # Time span for simulation t_span = (0, 50) t_eval = np.linspace(0, 50, 1000) # Solve ODE using Runge-Kutta method sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, method='RK45') # Extract results t = sol.t theta = sol.y[0] # Plot results plt.figure(figsize=(10, 5)) plt.plot(t, theta, label=r'$\\theta(t)$', color='b') plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle (rad)\") plt.title(\"Forced Damped Pendulum Motion\") plt.legend() plt.grid() plt.show() \ud83d\udcca 5. Results and Discussion \ud83d\udd39 Graph Interpretation At low damping ( \\( \\gamma \\ll 1 \\) ), large oscillations appear due to resonance. At high forcing amplitude ( \\( A \\gg 1 \\) ), the motion becomes irregular and chaotic. At specific frequencies ( \\( \\omega \\approx \\omega_0 \\) ), resonance occurs. \ud83d\udd39 Phase Space Analysis (Pendulum Motion in Phase Space) To visualize chaotic behavior, we can plot phase portraits ( \\( \\theta \\) vs. \\( \\dot{\\theta} \\) ): plt.figure(figsize=(6,6)) plt.plot(sol.y[0], sol.y[1], color='purple') plt.xlabel(r\"$\\theta$ (rad)\") plt.ylabel(r\"$\\dot{\\theta}$ (rad/s)\") plt.title(\"Phase Portrait of the Forced Damped Pendulum\") plt.grid() plt.show()","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#investigating-the-dynamics-of-a-forced-damped-pendulum","text":"","title":"\ud83d\udccc Investigating the Dynamics of a Forced Damped Pendulum"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#motivation","text":"The forced damped pendulum is a fascinating system that exhibits a range of behaviors, from simple oscillations to chaotic motion. By introducing damping and an external periodic force , we observe a transition from regular periodic motion to resonance, quasiperiodicity, and chaos . This system is crucial for understanding: - Resonance in mechanical systems (e.g., bridges, buildings under periodic stress). - Nonlinear dynamics and chaos theory (e.g., weather patterns, heart rhythms). - Energy harvesting from oscillations.","title":"\ud83c\udfd7 Motivation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#1-theoretical-foundation","text":"","title":"\u2696 1. Theoretical Foundation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#equation-of-motion","text":"The forced damped pendulum follows the nonlinear differential equation: \\[ \\ddot{\\theta} + \\gamma \\dot{\\theta} + \\omega_0^2 \\sin\\theta = A \\cos(\\omega t) \\] where: - \\( \\theta \\) = angular displacement - \\( \\gamma \\) = damping coefficient - \\( \\omega_0 \\) = natural frequency of the pendulum ( \\( \\omega_0 = \\sqrt{\\frac{g}{L}} \\) ) - \\( A \\) = amplitude of the external driving force - \\( \\omega \\) = driving frequency For small angles ( \\( \\theta \\approx \\sin\\theta \\) ), the equation simplifies to: \\[ \\ddot{\\theta} + \\gamma \\dot{\\theta} + \\omega_0^2 \\theta = A \\cos(\\omega t) \\] which resembles the equation of a driven damped harmonic oscillator .","title":"\ud83d\udcdc Equation of Motion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#resonance-condition","text":"Resonance occurs when the driving frequency \\( \\omega \\) matches the natural frequency \\( \\omega_0 \\) , leading to maximum energy absorption and large oscillations: \\[ \\omega_{\\text{res}} \\approx \\sqrt{\\omega_0^2 - \\frac{\\gamma^2}{4}} \\] At resonance, even small driving forces can produce large oscillations, which is crucial in mechanical engineering and structural safety .","title":"\ud83d\udccc Resonance Condition"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#2-analysis-of-dynamics","text":"","title":"\ud83d\udcca 2. Analysis of Dynamics"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#effect-of-damping-gamma","text":"Low damping: The pendulum exhibits large oscillations and resonance. High damping: The system stabilizes quickly with reduced oscillations.","title":"\ud83d\udd39 Effect of Damping (\\( \\gamma \\))"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#effect-of-driving-amplitude-a","text":"Low amplitude: The pendulum undergoes periodic motion. High amplitude: The system transitions into chaotic motion for certain frequencies.","title":"\ud83d\udd39 Effect of Driving Amplitude (\\( A \\))"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#effect-of-driving-frequency-omega","text":"When \\( \\omega \\approx \\omega_0 \\) , resonance occurs. When \\( \\omega \\) is far from \\( \\omega_0 \\) , the response is weak. Nonlinear behavior emerges at certain parameter values, leading to chaos.","title":"\ud83d\udd39 Effect of Driving Frequency (\\( \\omega \\))"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#3-practical-applications","text":"Engineering & Structural Dynamics Bridges & Skyscrapers: Understanding how periodic forces (e.g., wind, earthquakes) affect large structures. Vibration Isolation: Designing materials that minimize resonance effects. Energy Harvesting Pendulum-based generators: Extracting energy from periodic motion. Ocean wave energy devices. Chaos Theory & Climate Models Weather prediction models involve nonlinear oscillatory behaviors similar to the forced pendulum.","title":"\ud83c\udf0d 3. Practical Applications"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#4-implementation-python-simulation","text":"Below is a Python script that simulates the motion of a forced damped pendulum using numerical integration (Runge-Kutta method) .","title":"\ud83d\udcbb 4. Implementation (Python Simulation)"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#step-1-install-required-libraries","text":"Before running the code, install NumPy and Matplotlib if needed: pip install numpy matplotlib scipy","title":"\ud83d\udccc Step 1: Install Required Libraries"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#step-2-python-code-for-simulation","text":"import numpy as np import matplotlib.pyplot as plt from scipy.integrate import solve_ivp # Define system parameters g = 9.81 # Gravity (m/s\u00b2) L = 1.0 # Length of pendulum (m) gamma = 0.2 # Damping coefficient A = 1.5 # Driving amplitude omega = 2.0 # Driving frequency # Define natural frequency omega_0 = np.sqrt(g / L) # Define the equations of motion def forced_damped_pendulum(t, y): theta, omega_t = y dtheta_dt = omega_t domega_dt = -gamma * omega_t - omega_0**2 * np.sin(theta) + A * np.cos(omega * t) return [dtheta_dt, domega_dt] # Initial conditions: theta = 0.2 rad, omega = 0 rad/s y0 = [0.2, 0] # Time span for simulation t_span = (0, 50) t_eval = np.linspace(0, 50, 1000) # Solve ODE using Runge-Kutta method sol = solve_ivp(forced_damped_pendulum, t_span, y0, t_eval=t_eval, method='RK45') # Extract results t = sol.t theta = sol.y[0] # Plot results plt.figure(figsize=(10, 5)) plt.plot(t, theta, label=r'$\\theta(t)$', color='b') plt.xlabel(\"Time (s)\") plt.ylabel(\"Angle (rad)\") plt.title(\"Forced Damped Pendulum Motion\") plt.legend() plt.grid() plt.show()","title":"\ud83d\udccc Step 2: Python Code for Simulation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#5-results-and-discussion","text":"","title":"\ud83d\udcca 5. Results and Discussion"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#graph-interpretation","text":"At low damping ( \\( \\gamma \\ll 1 \\) ), large oscillations appear due to resonance. At high forcing amplitude ( \\( A \\gg 1 \\) ), the motion becomes irregular and chaotic. At specific frequencies ( \\( \\omega \\approx \\omega_0 \\) ), resonance occurs.","title":"\ud83d\udd39 Graph Interpretation"},{"location":"1%20Physics/1%20Mechanics/Problem_2/#phase-space-analysis-pendulum-motion-in-phase-space","text":"To visualize chaotic behavior, we can plot phase portraits ( \\( \\theta \\) vs. \\( \\dot{\\theta} \\) ): plt.figure(figsize=(6,6)) plt.plot(sol.y[0], sol.y[1], color='purple') plt.xlabel(r\"$\\theta$ (rad)\") plt.ylabel(r\"$\\dot{\\theta}$ (rad/s)\") plt.title(\"Phase Portrait of the Forced Damped Pendulum\") plt.grid() plt.show()","title":"\ud83d\udd39 Phase Space Analysis (Pendulum Motion in Phase Space)"},{"location":"1%20Physics/2%20Gravity/Problem_1/","text":"Problem 1 \ud83c\udf0d Orbital Period and Orbital Radius \ud83c\udfd7 Motivation Kepler's Third Law is a fundamental principle of celestial mechanics , stating that the square of a planet\u2019s orbital period is proportional to the cube of its orbital radius. This law, derived from Newton's Law of Universal Gravitation , is crucial for: - Understanding planetary motion and exoplanet detection - Designing satellite orbits - Calculating masses of celestial bodies By deriving and simulating this relationship, we gain insight into the governing laws of planetary systems. \u2696 1. Theoretical Foundation \ud83d\udcdc Derivation of Kepler\u2019s Third Law For a body in circular orbit around a much larger mass (e.g., a planet around a star), the gravitational force provides the necessary centripetal force : \\[ F_{\\text{gravity}} = F_{\\text{centripetal}} \\] Using Newton\u2019s Law of Gravitation : \\[ F_{\\text{gravity}} = \\frac{G M m}{r^2} \\] where: - \\( G \\) = Gravitational constant ( \\(6.674 \\times 10^{-11} \\, \\text{m}^3\\text{kg}^{-1}\\text{s}^{-2}\\) ) - \\( M \\) = Mass of the central body (e.g., Sun, Earth) - \\( m \\) = Mass of the orbiting body - \\( r \\) = Orbital radius The centripetal force needed to maintain circular motion is: \\[ F_{\\text{centripetal}} = \\frac{m v^2}{r} \\] Since \\( F_{\\text{gravity}} = F_{\\text{centripetal}} \\) : \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Canceling \\( m \\) and solving for velocity \\( v \\) : \\[ v = \\sqrt{\\frac{G M}{r}} \\] The orbital period \\( T \\) is the time taken to complete one orbit: \\[ T = \\frac{\\text{circumference}}{\\text{velocity}} = \\frac{2\\pi r}{v} \\] Substituting \\( v = \\sqrt{\\frac{G M}{r}} \\) : \\[ T = \\frac{2\\pi r}{\\sqrt{\\frac{G M}{r}}} = 2\\pi \\sqrt{\\frac{r^3}{G M}} \\] \ud83d\udd39 Kepler\u2019s Third Law (Final Form) \\[ T^2 = \\frac{4\\pi^2}{G M} r^3 \\] This shows that \\( T^2 \\) is proportional to \\( r^3 \\) : \\[ T^2 \\propto r^3 \\] \ud83d\udd39 Implications: - Larger orbits = Longer periods - Planets farther from the Sun move slower - The mass of the central body can be determined from orbital data \ud83c\udf0d 2. Real-World Examples 1. Earth's Moon Distance: \\( r = 3.844 \\times 10^8 \\) m Period: \\( T = 27.3 \\) days Using Kepler\u2019s Law, we can estimate Earth\u2019s mass. 2. Planets in the Solar System If we take Earth\u2019s orbit as a reference ( \\( r = 1 \\) AU, \\( T = 1 \\) year), then for any planet: \\[ \\frac{T_{\\text{planet}}^2}{r_{\\text{planet}}^3} \\approx 1 \\] This relationship helps predict unknown orbital parameters of newly discovered planets. \ud83d\udcbb 3. Implementation (Python Simulation) We\u2019ll verify Kepler\u2019s Third Law using numerical simulations. \ud83d\udccc Step 1: Install Dependencies Ensure NumPy and Matplotlib are installed: pip install numpy matplotlib \ud83d\udccc Step 2: Python Code for Simulation import numpy as np import matplotlib.pyplot as plt # Constants G = 6.674e-11 # Gravitational constant (m\u00b3/kg/s\u00b2) M_sun = 1.989e30 # Mass of the Sun (kg) AU = 1.496e11 # 1 Astronomical Unit in meters # Define orbital radii (in AU) for planets r_values_AU = np.array([0.39, 0.72, 1.0, 1.52, 5.2, 9.58, 19.18, 30.07]) # Mercury to Neptune r_values_m = r_values_AU * AU # Convert to meters # Compute orbital periods using Kepler's Law T_values_s = 2 * np.pi * np.sqrt(r_values_m**3 / (G * M_sun)) # In seconds T_values_years = T_values_s / (60 * 60 * 24 * 365) # Convert to years # Plot T\u00b2 vs. r\u00b3 to verify Kepler's Law plt.figure(figsize=(8, 5)) plt.plot(r_values_m**3, T_values_s**2, 'bo', label=\"Planets (Simulated Data)\") # Best-fit line (Kepler\u2019s relation) coeff = np.polyfit(r_values_m**3, T_values_s**2, 1) kepler_fit = np.poly1d(coeff) plt.plot(r_values_m**3, kepler_fit(r_values_m**3), 'r--', label=\"Kepler's Law Fit\") # Labels and title plt.xlabel(r\"Orbital Radius Cubed ($r^3$) [m\u00b3]\") plt.ylabel(r\"Orbital Period Squared ($T^2$) [s\u00b2]\") plt.title(\"Verification of Kepler's Third Law\") plt.legend() plt.grid() plt.show() \ud83d\udcca 4. Results and Discussion \ud83d\udd39 Graph Interpretation The data points align with a straight line , confirming \\( T^2 \\propto r^3 \\) . The best-fit line follows Kepler\u2019s predicted trend , verifying the law experimentally. \ud83d\udd39 Applications of Kepler\u2019s Law Finding Exoplanets : Measuring a planet\u2019s orbital period allows astronomers to estimate its distance from its star . Space Missions : Used in designing satellite orbits (e.g., GPS, geostationary satellites). \ud83d\udd39 Limitations Kepler\u2019s Law assumes circular orbits , but real orbits are elliptical . External forces (e.g., other planets\u2019 gravity) can slightly alter orbits . \ud83d\ude80 5. Extensions and Future Work Simulating elliptical orbits using Newton\u2019s second law numerically. Adding perturbations from additional celestial bodies (e.g., Jupiter\u2019s influence on Mars). Modeling binary star systems where both masses influence the motion. g","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/2%20Gravity/Problem_1/#orbital-period-and-orbital-radius","text":"","title":"\ud83c\udf0d Orbital Period and Orbital Radius"},{"location":"1%20Physics/2%20Gravity/Problem_1/#motivation","text":"Kepler's Third Law is a fundamental principle of celestial mechanics , stating that the square of a planet\u2019s orbital period is proportional to the cube of its orbital radius. This law, derived from Newton's Law of Universal Gravitation , is crucial for: - Understanding planetary motion and exoplanet detection - Designing satellite orbits - Calculating masses of celestial bodies By deriving and simulating this relationship, we gain insight into the governing laws of planetary systems.","title":"\ud83c\udfd7 Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-theoretical-foundation","text":"","title":"\u2696 1. Theoretical Foundation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#derivation-of-keplers-third-law","text":"For a body in circular orbit around a much larger mass (e.g., a planet around a star), the gravitational force provides the necessary centripetal force : \\[ F_{\\text{gravity}} = F_{\\text{centripetal}} \\] Using Newton\u2019s Law of Gravitation : \\[ F_{\\text{gravity}} = \\frac{G M m}{r^2} \\] where: - \\( G \\) = Gravitational constant ( \\(6.674 \\times 10^{-11} \\, \\text{m}^3\\text{kg}^{-1}\\text{s}^{-2}\\) ) - \\( M \\) = Mass of the central body (e.g., Sun, Earth) - \\( m \\) = Mass of the orbiting body - \\( r \\) = Orbital radius The centripetal force needed to maintain circular motion is: \\[ F_{\\text{centripetal}} = \\frac{m v^2}{r} \\] Since \\( F_{\\text{gravity}} = F_{\\text{centripetal}} \\) : \\[ \\frac{G M m}{r^2} = \\frac{m v^2}{r} \\] Canceling \\( m \\) and solving for velocity \\( v \\) : \\[ v = \\sqrt{\\frac{G M}{r}} \\] The orbital period \\( T \\) is the time taken to complete one orbit: \\[ T = \\frac{\\text{circumference}}{\\text{velocity}} = \\frac{2\\pi r}{v} \\] Substituting \\( v = \\sqrt{\\frac{G M}{r}} \\) : \\[ T = \\frac{2\\pi r}{\\sqrt{\\frac{G M}{r}}} = 2\\pi \\sqrt{\\frac{r^3}{G M}} \\]","title":"\ud83d\udcdc Derivation of Kepler\u2019s Third Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#keplers-third-law-final-form","text":"\\[ T^2 = \\frac{4\\pi^2}{G M} r^3 \\] This shows that \\( T^2 \\) is proportional to \\( r^3 \\) : \\[ T^2 \\propto r^3 \\] \ud83d\udd39 Implications: - Larger orbits = Longer periods - Planets farther from the Sun move slower - The mass of the central body can be determined from orbital data","title":"\ud83d\udd39 Kepler\u2019s Third Law (Final Form)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-real-world-examples","text":"","title":"\ud83c\udf0d 2. Real-World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_1/#1-earths-moon","text":"Distance: \\( r = 3.844 \\times 10^8 \\) m Period: \\( T = 27.3 \\) days Using Kepler\u2019s Law, we can estimate Earth\u2019s mass.","title":"1. Earth's Moon"},{"location":"1%20Physics/2%20Gravity/Problem_1/#2-planets-in-the-solar-system","text":"If we take Earth\u2019s orbit as a reference ( \\( r = 1 \\) AU, \\( T = 1 \\) year), then for any planet: \\[ \\frac{T_{\\text{planet}}^2}{r_{\\text{planet}}^3} \\approx 1 \\] This relationship helps predict unknown orbital parameters of newly discovered planets.","title":"2. Planets in the Solar System"},{"location":"1%20Physics/2%20Gravity/Problem_1/#3-implementation-python-simulation","text":"We\u2019ll verify Kepler\u2019s Third Law using numerical simulations.","title":"\ud83d\udcbb 3. Implementation (Python Simulation)"},{"location":"1%20Physics/2%20Gravity/Problem_1/#step-1-install-dependencies","text":"Ensure NumPy and Matplotlib are installed: pip install numpy matplotlib","title":"\ud83d\udccc Step 1: Install Dependencies"},{"location":"1%20Physics/2%20Gravity/Problem_1/#step-2-python-code-for-simulation","text":"import numpy as np import matplotlib.pyplot as plt # Constants G = 6.674e-11 # Gravitational constant (m\u00b3/kg/s\u00b2) M_sun = 1.989e30 # Mass of the Sun (kg) AU = 1.496e11 # 1 Astronomical Unit in meters # Define orbital radii (in AU) for planets r_values_AU = np.array([0.39, 0.72, 1.0, 1.52, 5.2, 9.58, 19.18, 30.07]) # Mercury to Neptune r_values_m = r_values_AU * AU # Convert to meters # Compute orbital periods using Kepler's Law T_values_s = 2 * np.pi * np.sqrt(r_values_m**3 / (G * M_sun)) # In seconds T_values_years = T_values_s / (60 * 60 * 24 * 365) # Convert to years # Plot T\u00b2 vs. r\u00b3 to verify Kepler's Law plt.figure(figsize=(8, 5)) plt.plot(r_values_m**3, T_values_s**2, 'bo', label=\"Planets (Simulated Data)\") # Best-fit line (Kepler\u2019s relation) coeff = np.polyfit(r_values_m**3, T_values_s**2, 1) kepler_fit = np.poly1d(coeff) plt.plot(r_values_m**3, kepler_fit(r_values_m**3), 'r--', label=\"Kepler's Law Fit\") # Labels and title plt.xlabel(r\"Orbital Radius Cubed ($r^3$) [m\u00b3]\") plt.ylabel(r\"Orbital Period Squared ($T^2$) [s\u00b2]\") plt.title(\"Verification of Kepler's Third Law\") plt.legend() plt.grid() plt.show()","title":"\ud83d\udccc Step 2: Python Code for Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#4-results-and-discussion","text":"","title":"\ud83d\udcca 4. Results and Discussion"},{"location":"1%20Physics/2%20Gravity/Problem_1/#graph-interpretation","text":"The data points align with a straight line , confirming \\( T^2 \\propto r^3 \\) . The best-fit line follows Kepler\u2019s predicted trend , verifying the law experimentally.","title":"\ud83d\udd39 Graph Interpretation"},{"location":"1%20Physics/2%20Gravity/Problem_1/#applications-of-keplers-law","text":"Finding Exoplanets : Measuring a planet\u2019s orbital period allows astronomers to estimate its distance from its star . Space Missions : Used in designing satellite orbits (e.g., GPS, geostationary satellites).","title":"\ud83d\udd39 Applications of Kepler\u2019s Law"},{"location":"1%20Physics/2%20Gravity/Problem_1/#limitations","text":"Kepler\u2019s Law assumes circular orbits , but real orbits are elliptical . External forces (e.g., other planets\u2019 gravity) can slightly alter orbits .","title":"\ud83d\udd39 Limitations"},{"location":"1%20Physics/2%20Gravity/Problem_1/#5-extensions-and-future-work","text":"Simulating elliptical orbits using Newton\u2019s second law numerically. Adding perturbations from additional celestial bodies (e.g., Jupiter\u2019s influence on Mars). Modeling binary star systems where both masses influence the motion. g","title":"\ud83d\ude80 5. Extensions and Future Work"},{"location":"1%20Physics/2%20Gravity/Problem_2/","text":"Problem 2 Escape Velocities and Cosmic Velocities \ud83d\ude80 Motivation The concept of escape velocity is fundamental to space exploration, determining the energy required to break free from a celestial body's gravitational pull. Understanding the first, second, and third cosmic velocities enables us to: Design satellite launch profiles Plan interplanetary missions Conceptualize interstellar travel Understand fundamental astrophysical processes These velocity thresholds govern everything from placing satellites in orbit to sending probes beyond our solar system. \ud83d\udcda Theoretical Foundations \ud83c\udf10 First Cosmic Velocity (Orbital Velocity) Physical Meaning: The minimum horizontal speed required to maintain a stable circular orbit just above a celestial body's atmosphere. Mathematical Expression: v\u2081 = \u221a(GM/R) Where: - G = Gravitational constant (6.67430 \u00d7 10\u207b\u00b9\u00b9 m\u00b3 kg\u207b\u00b9 s\u207b\u00b2) - M = Mass of the celestial body - R = Radius of the celestial body \ud83e\ude90 Second Cosmic Velocity (Escape Velocity) Physical Meaning: The minimum speed needed to completely escape a celestial body's gravitational field from its surface without additional propulsion. Mathematical Expression: v\u2082 = \u221a(2GM/R) = v\u2081 \u00d7 \u221a2 \ud83c\udf0c Third Cosmic Velocity Physical Meaning: The minimum speed required at Earth's surface to escape not just Earth's gravity, but the entire solar system's gravitational influence. Mathematical Expression: v\u2083 = \u221a(v\u2082\u00b2 + (v\u2299 \u00d7 \u221a2)\u00b2) Where v\u2299 is the solar escape velocity at Earth's orbital distance. \ud83d\udd0d Key Parameters These velocities depend on: - Mass of the body - More massive objects require higher velocities - Radius of the body - Larger radii result in lower escape velocities - Orbital position (for third cosmic velocity) - Distance from the central star matters \ud83d\udcbb Computational Implementation import numpy as np import matplotlib.pyplot as plt from matplotlib import cm # Constants G = 6.67430e-11 # Gravitational constant (m\u00b3 kg\u207b\u00b9 s\u207b\u00b2) AU = 1.496e11 # Astronomical Unit (m) sun_mass = 1.989e30 # Solar mass (kg) # Celestial body database bodies = { 'Earth': {'mass': 5.972e24, 'radius': 6.371e6, 'color': '#2E86AB'}, 'Mars': {'mass': 6.39e23, 'radius': 3.3895e6, 'color': '#E83F6F'}, 'Jupiter': {'mass': 1.898e27, 'radius': 6.9911e7, 'color': '#FF9F1C'} } def calculate_cosmic_velocities(body): \"\"\"Compute all three cosmic velocities for a celestial body\"\"\" M, R = body['mass'], body['radius'] # First cosmic velocity v1 = np.sqrt(G * M / R) # Second cosmic velocity v2 = np.sqrt(2 * G * M / R) # Third cosmic velocity (solar system escape) v_sun_escape = np.sqrt(2 * G * sun_mass / AU) v3 = np.sqrt(v2**2 + v_sun_escape**2) return v1, v2, v3 # Calculate and display results print(\"| Celestial Body | 1st Cosmic (km/s) | 2nd Cosmic (km/s) | 3rd Cosmic (km/s) |\") print(\"|----------------|-------------------|-------------------|-------------------|\") for name, data in bodies.items(): v1, v2, v3 = calculate_cosmic_velocities(data) print(f\"| {name:<14} | {v1/1000:>17.2f} | {v2/1000:>17.2f} | {v3/1000:>17.2f} |\") # Visualization fig, ax = plt.subplots(figsize=(10, 6), dpi=100) x = np.arange(len(bodies)) width = 0.25 # Create bars for each velocity for i, (velocity, label) in enumerate(zip( ['1st Cosmic', '2nd Cosmic', '3rd Cosmic'], ['Orbital Velocity', 'Escape Velocity', 'Solar System Escape'] )): values = [calculate_cosmic_velocities(body)[i]/1000 for body in bodies.values()] colors = [body['color'] for body in bodies.values()] ax.bar(x + i*width, values, width, label=label, color=colors) # Formatting ax.set_ylabel('Velocity (km/s)', fontsize=12) ax.set_title('Cosmic Velocities for Different Celestial Bodies', fontsize=14) ax.set_xticks(x + width) ax.set_xticklabels(bodies.keys(), fontsize=12) ax.legend(fontsize=10) ax.grid(axis='y', linestyle='--', alpha=0.7) plt.tight_layout() plt.show() \ud83d\udcca Results and Analysis Sample Output: | Celestial Body | 1st Cosmic (km/s) | 2nd Cosmic (km/s) | 3rd Cosmic (km/s) | |----------------|-------------------|-------------------|-------------------| | Earth | 7.91 | 11.19 | 16.65 | | Mars | 3.55 | 5.03 | 7.83 | | Jupiter | 42.51 | 60.12 | 61.39 | Key Observations: Jupiter's Dominance : The gas giant's massive size results in escape velocities over 5\u00d7 Earth's Mars Accessibility : Lower velocities make Mars an attractive target for missions Solar System Escape : The third cosmic velocity shows the additional energy needed to leave our solar system \ud83d\udef0\ufe0f Applications in Space Exploration First Cosmic Velocity: Satellite deployment in low orbits Space station maintenance Earth observation missions Second Cosmic Velocity: Lunar missions Interplanetary travel Deep space probe launches Third Cosmic Velocity: Voyager missions leaving the heliosphere Future interstellar probes Understanding the Sun's gravitational influence \ud83d\udd2e Future Extensions Relativistic Effects : Incorporating Einstein's corrections for extreme gravity Atmospheric Drag : Modeling real-world launch conditions Multi-body Systems : Calculating velocities in binary star systems Variable Gravity : Exploring non-spherical mass distributions This analysis demonstrates how fundamental physics principles govern humanity's ability to explore space, from placing satellites in orbit to dreaming of interstellar travel.","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/2%20Gravity/Problem_2/#escape-velocities-and-cosmic-velocities","text":"","title":"Escape Velocities and Cosmic Velocities"},{"location":"1%20Physics/2%20Gravity/Problem_2/#motivation","text":"The concept of escape velocity is fundamental to space exploration, determining the energy required to break free from a celestial body's gravitational pull. Understanding the first, second, and third cosmic velocities enables us to: Design satellite launch profiles Plan interplanetary missions Conceptualize interstellar travel Understand fundamental astrophysical processes These velocity thresholds govern everything from placing satellites in orbit to sending probes beyond our solar system.","title":"\ud83d\ude80 Motivation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#theoretical-foundations","text":"","title":"\ud83d\udcda Theoretical Foundations"},{"location":"1%20Physics/2%20Gravity/Problem_2/#first-cosmic-velocity-orbital-velocity","text":"Physical Meaning: The minimum horizontal speed required to maintain a stable circular orbit just above a celestial body's atmosphere. Mathematical Expression: v\u2081 = \u221a(GM/R) Where: - G = Gravitational constant (6.67430 \u00d7 10\u207b\u00b9\u00b9 m\u00b3 kg\u207b\u00b9 s\u207b\u00b2) - M = Mass of the celestial body - R = Radius of the celestial body","title":"\ud83c\udf10 First Cosmic Velocity (Orbital Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#second-cosmic-velocity-escape-velocity","text":"Physical Meaning: The minimum speed needed to completely escape a celestial body's gravitational field from its surface without additional propulsion. Mathematical Expression: v\u2082 = \u221a(2GM/R) = v\u2081 \u00d7 \u221a2","title":"\ud83e\ude90 Second Cosmic Velocity (Escape Velocity)"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity","text":"Physical Meaning: The minimum speed required at Earth's surface to escape not just Earth's gravity, but the entire solar system's gravitational influence. Mathematical Expression: v\u2083 = \u221a(v\u2082\u00b2 + (v\u2299 \u00d7 \u221a2)\u00b2) Where v\u2299 is the solar escape velocity at Earth's orbital distance.","title":"\ud83c\udf0c Third Cosmic Velocity"},{"location":"1%20Physics/2%20Gravity/Problem_2/#key-parameters","text":"These velocities depend on: - Mass of the body - More massive objects require higher velocities - Radius of the body - Larger radii result in lower escape velocities - Orbital position (for third cosmic velocity) - Distance from the central star matters","title":"\ud83d\udd0d Key Parameters"},{"location":"1%20Physics/2%20Gravity/Problem_2/#computational-implementation","text":"import numpy as np import matplotlib.pyplot as plt from matplotlib import cm # Constants G = 6.67430e-11 # Gravitational constant (m\u00b3 kg\u207b\u00b9 s\u207b\u00b2) AU = 1.496e11 # Astronomical Unit (m) sun_mass = 1.989e30 # Solar mass (kg) # Celestial body database bodies = { 'Earth': {'mass': 5.972e24, 'radius': 6.371e6, 'color': '#2E86AB'}, 'Mars': {'mass': 6.39e23, 'radius': 3.3895e6, 'color': '#E83F6F'}, 'Jupiter': {'mass': 1.898e27, 'radius': 6.9911e7, 'color': '#FF9F1C'} } def calculate_cosmic_velocities(body): \"\"\"Compute all three cosmic velocities for a celestial body\"\"\" M, R = body['mass'], body['radius'] # First cosmic velocity v1 = np.sqrt(G * M / R) # Second cosmic velocity v2 = np.sqrt(2 * G * M / R) # Third cosmic velocity (solar system escape) v_sun_escape = np.sqrt(2 * G * sun_mass / AU) v3 = np.sqrt(v2**2 + v_sun_escape**2) return v1, v2, v3 # Calculate and display results print(\"| Celestial Body | 1st Cosmic (km/s) | 2nd Cosmic (km/s) | 3rd Cosmic (km/s) |\") print(\"|----------------|-------------------|-------------------|-------------------|\") for name, data in bodies.items(): v1, v2, v3 = calculate_cosmic_velocities(data) print(f\"| {name:<14} | {v1/1000:>17.2f} | {v2/1000:>17.2f} | {v3/1000:>17.2f} |\") # Visualization fig, ax = plt.subplots(figsize=(10, 6), dpi=100) x = np.arange(len(bodies)) width = 0.25 # Create bars for each velocity for i, (velocity, label) in enumerate(zip( ['1st Cosmic', '2nd Cosmic', '3rd Cosmic'], ['Orbital Velocity', 'Escape Velocity', 'Solar System Escape'] )): values = [calculate_cosmic_velocities(body)[i]/1000 for body in bodies.values()] colors = [body['color'] for body in bodies.values()] ax.bar(x + i*width, values, width, label=label, color=colors) # Formatting ax.set_ylabel('Velocity (km/s)', fontsize=12) ax.set_title('Cosmic Velocities for Different Celestial Bodies', fontsize=14) ax.set_xticks(x + width) ax.set_xticklabels(bodies.keys(), fontsize=12) ax.legend(fontsize=10) ax.grid(axis='y', linestyle='--', alpha=0.7) plt.tight_layout() plt.show()","title":"\ud83d\udcbb Computational Implementation"},{"location":"1%20Physics/2%20Gravity/Problem_2/#results-and-analysis","text":"","title":"\ud83d\udcca Results and Analysis"},{"location":"1%20Physics/2%20Gravity/Problem_2/#sample-output","text":"| Celestial Body | 1st Cosmic (km/s) | 2nd Cosmic (km/s) | 3rd Cosmic (km/s) | |----------------|-------------------|-------------------|-------------------| | Earth | 7.91 | 11.19 | 16.65 | | Mars | 3.55 | 5.03 | 7.83 | | Jupiter | 42.51 | 60.12 | 61.39 |","title":"Sample Output:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#key-observations","text":"Jupiter's Dominance : The gas giant's massive size results in escape velocities over 5\u00d7 Earth's Mars Accessibility : Lower velocities make Mars an attractive target for missions Solar System Escape : The third cosmic velocity shows the additional energy needed to leave our solar system","title":"Key Observations:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#applications-in-space-exploration","text":"","title":"\ud83d\udef0\ufe0f Applications in Space Exploration"},{"location":"1%20Physics/2%20Gravity/Problem_2/#first-cosmic-velocity","text":"Satellite deployment in low orbits Space station maintenance Earth observation missions","title":"First Cosmic Velocity:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#second-cosmic-velocity","text":"Lunar missions Interplanetary travel Deep space probe launches","title":"Second Cosmic Velocity:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#third-cosmic-velocity_1","text":"Voyager missions leaving the heliosphere Future interstellar probes Understanding the Sun's gravitational influence","title":"Third Cosmic Velocity:"},{"location":"1%20Physics/2%20Gravity/Problem_2/#future-extensions","text":"Relativistic Effects : Incorporating Einstein's corrections for extreme gravity Atmospheric Drag : Modeling real-world launch conditions Multi-body Systems : Calculating velocities in binary star systems Variable Gravity : Exploring non-spherical mass distributions This analysis demonstrates how fundamental physics principles govern humanity's ability to explore space, from placing satellites in orbit to dreaming of interstellar travel.","title":"\ud83d\udd2e Future Extensions"},{"location":"1%20Physics/2%20Gravity/Problem_3/","text":"Problem 3 \ud83c\udf1f Payload Trajectories Around Earth Explained Simply \ud83d\ude80 Why This Matters (In Plain Terms) When we drop something from space (like a satellite from a rocket), its path isn't simple! Depending on how fast it's moving when released, it can: - Circle Earth like the ISS (like throwing a ball fast enough to miss the ground) - Fall back to Earth (like a normal dropped ball) - Fly away forever (like throwing a baseball into space) Understanding these paths helps scientists: - Put satellites where they need to go - Bring astronauts home safely - Plan missions to other planets \ud83d\udd0d The Science Made Simple \ud83c\udfaf What Decides the Path? Just two main things: 1. How high you are when you let go 2. How fast you're moving when you let go \ud83d\udee4\ufe0f The Possible Paths: Path Type What Happens Real-World Example Circular Perfect Earth circle GPS satellites Elliptical Oval path around Earth Hubble Space Telescope Suborbital Falls back to Earth Space tourist flights Escape Leaves Earth permanently Voyager spacecraft \ud83d\udcbb Try It Yourself - Simple Simulation # Super simple orbit simulator import matplotlib.pyplot as plt import numpy as np # Earth settings earth_radius = 6371 # km earth = plt.Circle((0, 0), earth_radius, color='#2E86AB') # Simple trajectory calculator def calculate_path(speed, height): time = np.linspace(0, 100, 1000) x = speed * time y = height - 0.5 * 9.8 * time**2 return x, y # Create plot fig, ax = plt.subplots(figsize=(10, 8)) ax.add_patch(earth) ax.set_xlim(-20000, 20000) ax.set_ylim(-2000, 15000) ax.set_aspect('equal') # Try different speeds (change these numbers!) slow_path = calculate_path(100, 300) # Falls down fast_path = calculate_path(2000, 300) # Orbits escape_path = calculate_path(4000, 300) # Escapes Earth # Plot the paths ax.plot(*slow_path, 'r-', label=\"Slow - Falls back\") ax.plot(*fast_path, 'g-', label=\"Fast - Orbits\") ax.plot(*escape_path, 'y-', label=\"Super fast - Escapes\") plt.title(\"Different Paths From Same Height\", size=16) plt.xlabel(\"Distance (km)\") plt.ylabel(\"Height (km)\") plt.legend() plt.grid(True, alpha=0.3) plt.show() \ud83d\udcca What You'll See The simulation shows three paths from the same height: 1. Red Path : Too slow - falls back to Earth 2. Green Path : Just right - orbits Earth 3. Yellow Path : Super fast - escapes Earth's pull \ud83c\udf0e Real World Examples \ud83d\udef0\ufe0f Satellite Deployment Problem : Need to place a weather satellite in perfect orbit Solution : Release it at exactly 7.8 km/s speed at 400 km height \ud83e\uddd1\ud83d\ude80 Astronaut Return Problem : Bring astronauts home safely Solution : Slow down just enough to fall through atmosphere carefully \ud83d\ude80 Mars Missions Problem : Send spacecraft to Mars Solution : Accelerate to 11.2 km/s to escape Earth, then adjust course \ud83d\udca1 Key Takeaways Speed is everything : A little faster makes a big difference! Height helps : It's easier to orbit from higher up Perfect balance : Orbiting is like falling but moving sideways so fast you miss the ground \ud83c\udf93 Learn More With This Simple Analogy Imagine throwing a ball: - Normal throw (slow) \u2192 Hits ground - Really fast throw \u2192 Could orbit Earth (if no air resistance) - Incredibly fast throw \u2192 Leaves Earth forever That's essentially how space trajectories work!","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#problem-3","text":"","title":"Problem 3"},{"location":"1%20Physics/2%20Gravity/Problem_3/#payload-trajectories-around-earth-explained-simply","text":"","title":"\ud83c\udf1f Payload Trajectories Around Earth Explained Simply"},{"location":"1%20Physics/2%20Gravity/Problem_3/#why-this-matters-in-plain-terms","text":"When we drop something from space (like a satellite from a rocket), its path isn't simple! Depending on how fast it's moving when released, it can: - Circle Earth like the ISS (like throwing a ball fast enough to miss the ground) - Fall back to Earth (like a normal dropped ball) - Fly away forever (like throwing a baseball into space) Understanding these paths helps scientists: - Put satellites where they need to go - Bring astronauts home safely - Plan missions to other planets","title":"\ud83d\ude80 Why This Matters (In Plain Terms)"},{"location":"1%20Physics/2%20Gravity/Problem_3/#the-science-made-simple","text":"","title":"\ud83d\udd0d The Science Made Simple"},{"location":"1%20Physics/2%20Gravity/Problem_3/#what-decides-the-path","text":"Just two main things: 1. How high you are when you let go 2. How fast you're moving when you let go","title":"\ud83c\udfaf What Decides the Path?"},{"location":"1%20Physics/2%20Gravity/Problem_3/#the-possible-paths","text":"Path Type What Happens Real-World Example Circular Perfect Earth circle GPS satellites Elliptical Oval path around Earth Hubble Space Telescope Suborbital Falls back to Earth Space tourist flights Escape Leaves Earth permanently Voyager spacecraft","title":"\ud83d\udee4\ufe0f The Possible Paths:"},{"location":"1%20Physics/2%20Gravity/Problem_3/#try-it-yourself-simple-simulation","text":"# Super simple orbit simulator import matplotlib.pyplot as plt import numpy as np # Earth settings earth_radius = 6371 # km earth = plt.Circle((0, 0), earth_radius, color='#2E86AB') # Simple trajectory calculator def calculate_path(speed, height): time = np.linspace(0, 100, 1000) x = speed * time y = height - 0.5 * 9.8 * time**2 return x, y # Create plot fig, ax = plt.subplots(figsize=(10, 8)) ax.add_patch(earth) ax.set_xlim(-20000, 20000) ax.set_ylim(-2000, 15000) ax.set_aspect('equal') # Try different speeds (change these numbers!) slow_path = calculate_path(100, 300) # Falls down fast_path = calculate_path(2000, 300) # Orbits escape_path = calculate_path(4000, 300) # Escapes Earth # Plot the paths ax.plot(*slow_path, 'r-', label=\"Slow - Falls back\") ax.plot(*fast_path, 'g-', label=\"Fast - Orbits\") ax.plot(*escape_path, 'y-', label=\"Super fast - Escapes\") plt.title(\"Different Paths From Same Height\", size=16) plt.xlabel(\"Distance (km)\") plt.ylabel(\"Height (km)\") plt.legend() plt.grid(True, alpha=0.3) plt.show()","title":"\ud83d\udcbb Try It Yourself - Simple Simulation"},{"location":"1%20Physics/2%20Gravity/Problem_3/#what-youll-see","text":"The simulation shows three paths from the same height: 1. Red Path : Too slow - falls back to Earth 2. Green Path : Just right - orbits Earth 3. Yellow Path : Super fast - escapes Earth's pull","title":"\ud83d\udcca What You'll See"},{"location":"1%20Physics/2%20Gravity/Problem_3/#real-world-examples","text":"","title":"\ud83c\udf0e Real World Examples"},{"location":"1%20Physics/2%20Gravity/Problem_3/#satellite-deployment","text":"Problem : Need to place a weather satellite in perfect orbit Solution : Release it at exactly 7.8 km/s speed at 400 km height","title":"\ud83d\udef0\ufe0f Satellite Deployment"},{"location":"1%20Physics/2%20Gravity/Problem_3/#astronaut-return","text":"Problem : Bring astronauts home safely Solution : Slow down just enough to fall through atmosphere carefully","title":"\ud83e\uddd1\ud83d\ude80 Astronaut Return"},{"location":"1%20Physics/2%20Gravity/Problem_3/#mars-missions","text":"Problem : Send spacecraft to Mars Solution : Accelerate to 11.2 km/s to escape Earth, then adjust course","title":"\ud83d\ude80 Mars Missions"},{"location":"1%20Physics/2%20Gravity/Problem_3/#key-takeaways","text":"Speed is everything : A little faster makes a big difference! Height helps : It's easier to orbit from higher up Perfect balance : Orbiting is like falling but moving sideways so fast you miss the ground","title":"\ud83d\udca1 Key Takeaways"},{"location":"1%20Physics/2%20Gravity/Problem_3/#learn-more-with-this-simple-analogy","text":"Imagine throwing a ball: - Normal throw (slow) \u2192 Hits ground - Really fast throw \u2192 Could orbit Earth (if no air resistance) - Incredibly fast throw \u2192 Leaves Earth forever That's essentially how space trajectories work!","title":"\ud83c\udf93 Learn More With This Simple Analogy"},{"location":"1%20Physics/3%20Waves/Problem_1/","text":"\ud83c\udf0a Interference Patterns on a Water Surface \ud83c\udfaf Motivation Interference occurs when waves from different sources meet and overlap. On a water surface, we can clearly see these effects when ripples from different points intersect. The resulting pattern helps us understand how waves reinforce or cancel each other out. Studying these patterns: - Makes wave physics visual and intuitive - Helps us learn about wave phase , superposition , and wave behavior - Can be used in real-world applications like acoustics, optics, and engineering \ud83d\udccc Problem Statement We want to analyze interference patterns created by multiple point wave sources placed at the vertices of a regular polygon (like a triangle, square, or pentagon). A single circular wave is described by: 5. Analyze Patterns Observe regions of: - Constructive interference (waves add) - Destructive interference (waves cancel) 6. Visualize We'll use Python + Matplotlib to simulate and visualize the interference. \ud83e\uddea Python Simulation ```python import numpy as np import matplotlib.pyplot as plt Wave parameters A = 1 lambda_ = 1 f = 1 omega = 2 * np.pi * f k = 2 * np.pi / lambda_ phi = 0 radius = 5 num_sources = 4 # square grid_size = 200 Grid x = np.linspace(-10, 10, grid_size) y = np.linspace(-10, 10, grid_size) X, Y = np.meshgrid(x, y) Source positions (square shape) theta = np.linspace(0, 2 * np.pi, num_sources, endpoint=False) source_x = radius * np.cos(theta) source_y = radius * np.sin(theta) Time snapshot t = 0 Wave function def wave(x, y, sx, sy): r = np.sqrt((x - sx) 2 + (y - sy) 2) return A * np.cos(k * r - omega * t + phi) Total wave from all sources total = np.zeros_like(X) for i in range(num_sources): total += wave(X, Y, source_x[i], source_y[i]) plt.figure(figsize=(8, 6)) plt.imshow(total, extent=[-10, 10, -10, 10], cmap='coolwarm', origin='lower') plt.colorbar(label='Wave Displacement') plt.scatter(source_x, source_y, color='yellow', edgecolors='black', s=100, label='Sources') plt.title(\"Interference Pattern (Heatmap)\", fontsize=14) plt.xlabel(\"X\") plt.ylabel(\"Y\") plt.grid(True, linestyle='--', alpha=0.3) plt.legend() plt.show() plt.figure(figsize=(8, 6)) plt.contour(X, Y, total, levels=20, cmap='plasma') plt.scatter(source_x, source_y, color='yellow', edgecolors='black', s=100) plt.title(\"Contour Lines of Wave Interference\") plt.xlabel(\"X\") plt.ylabel(\"Y\") plt.grid(True, linestyle='--', alpha=0.3) plt.show()","title":"\ud83c\udf0a Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#interference-patterns-on-a-water-surface","text":"","title":"\ud83c\udf0a Interference Patterns on a Water Surface"},{"location":"1%20Physics/3%20Waves/Problem_1/#motivation","text":"Interference occurs when waves from different sources meet and overlap. On a water surface, we can clearly see these effects when ripples from different points intersect. The resulting pattern helps us understand how waves reinforce or cancel each other out. Studying these patterns: - Makes wave physics visual and intuitive - Helps us learn about wave phase , superposition , and wave behavior - Can be used in real-world applications like acoustics, optics, and engineering","title":"\ud83c\udfaf Motivation"},{"location":"1%20Physics/3%20Waves/Problem_1/#problem-statement","text":"We want to analyze interference patterns created by multiple point wave sources placed at the vertices of a regular polygon (like a triangle, square, or pentagon).","title":"\ud83d\udccc Problem Statement"},{"location":"1%20Physics/3%20Waves/Problem_1/#a-single-circular-wave-is-described-by","text":"","title":"A single circular wave is described by:"},{"location":"1%20Physics/3%20Waves/Problem_1/#5-analyze-patterns","text":"Observe regions of: - Constructive interference (waves add) - Destructive interference (waves cancel)","title":"5. Analyze Patterns"},{"location":"1%20Physics/3%20Waves/Problem_1/#6-visualize","text":"We'll use Python + Matplotlib to simulate and visualize the interference.","title":"6. Visualize"},{"location":"1%20Physics/3%20Waves/Problem_1/#python-simulation","text":"```python import numpy as np import matplotlib.pyplot as plt","title":"\ud83e\uddea Python Simulation"},{"location":"1%20Physics/3%20Waves/Problem_1/#wave-parameters","text":"A = 1 lambda_ = 1 f = 1 omega = 2 * np.pi * f k = 2 * np.pi / lambda_ phi = 0 radius = 5 num_sources = 4 # square grid_size = 200","title":"Wave parameters"},{"location":"1%20Physics/3%20Waves/Problem_1/#grid","text":"x = np.linspace(-10, 10, grid_size) y = np.linspace(-10, 10, grid_size) X, Y = np.meshgrid(x, y)","title":"Grid"},{"location":"1%20Physics/3%20Waves/Problem_1/#source-positions-square-shape","text":"theta = np.linspace(0, 2 * np.pi, num_sources, endpoint=False) source_x = radius * np.cos(theta) source_y = radius * np.sin(theta)","title":"Source positions (square shape)"},{"location":"1%20Physics/3%20Waves/Problem_1/#time-snapshot","text":"t = 0","title":"Time snapshot"},{"location":"1%20Physics/3%20Waves/Problem_1/#wave-function","text":"def wave(x, y, sx, sy): r = np.sqrt((x - sx) 2 + (y - sy) 2) return A * np.cos(k * r - omega * t + phi)","title":"Wave function"},{"location":"1%20Physics/3%20Waves/Problem_1/#total-wave-from-all-sources","text":"total = np.zeros_like(X) for i in range(num_sources): total += wave(X, Y, source_x[i], source_y[i]) plt.figure(figsize=(8, 6)) plt.imshow(total, extent=[-10, 10, -10, 10], cmap='coolwarm', origin='lower') plt.colorbar(label='Wave Displacement') plt.scatter(source_x, source_y, color='yellow', edgecolors='black', s=100, label='Sources') plt.title(\"Interference Pattern (Heatmap)\", fontsize=14) plt.xlabel(\"X\") plt.ylabel(\"Y\") plt.grid(True, linestyle='--', alpha=0.3) plt.legend() plt.show() plt.figure(figsize=(8, 6)) plt.contour(X, Y, total, levels=20, cmap='plasma') plt.scatter(source_x, source_y, color='yellow', edgecolors='black', s=100) plt.title(\"Contour Lines of Wave Interference\") plt.xlabel(\"X\") plt.ylabel(\"Y\") plt.grid(True, linestyle='--', alpha=0.3) plt.show()","title":"Total wave from all sources"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/","text":"\ud83c\udf2a\ufe0f Lorentz Force Simulator: See Charged Particles Dance! \ud83c\udf2a\ufe0f (No scary math - just cool visuals and simple explanations!) \ud83d\udd0d What is Lorentz Force? It's the push/pull on charged particles in electric (\u26a1) and magnetic (\ud83e\uddf2) fields. Formula (for nerds): F = q(E + v \u00d7 B) (But we'll focus on what it DOES, not the math!) \ud83d\ude80 Where This Matters in Real Life Application How Lorentz Force Helps Particle Accelerators \ud83c\udf00 Keeps particles moving in perfect circles Mass Spectrometers \ud83d\udd0d Separates atoms by mass/charge ratio Fusion Reactors \u2600\ufe0f Traps super-hot plasma with magnetic fields \ud83d\udcbb Let's Simulate It! (Python Code) (Try changing the numbers to see what happens!) import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Set up fields and particle q = 1.6e-19 # Charge (Coulombs) m = 9.1e-31 # Mass (kg) B = np.array([0, 0, 1.0]) # Magnetic field (Tesla) \u2192 along Z-axis E = np.array([0.1, 0, 0]) # Electric field (V/m) \u2192 along X-axis v = np.array([1.0, 0, 0]) # Initial velocity (m/s) # Time settings dt = 1e-10 # Time step (seconds) steps = 1000 positions = np.zeros((steps, 3)) # Simulation loop for i in range(1, steps): F = q * (E + np.cross(v, B)) # Lorentz Force! a = F / m # Acceleration v += a * dt positions[i] = positions[i-1] + v * dt # Plotting fig = plt.figure(figsize=(12, 6)) ax = fig.add_subplot(121, projection='3d') ax.plot(*positions.T, lw=2) ax.set_title(\"3D Trajectory\") ax.set_xlabel(\"X\"); ax.set_ylabel(\"Y\"); ax.set_zlabel(\"Z\") ax2 = fig.add_subplot(122) ax2.plot(positions[:,0], positions[:,1]) ax2.set_title(\"Top View (XY Plane)\") plt.tight_layout() plt.show() \ud83c\udf00 What You'll See Pure Magnetic Field (B only): Particle spirals \ud83c\udf00 in a perfect helix (Like a rollercoaster with no end!) Electric + Magnetic (E \u22a5 B): Particle drifts sideways \u27a1\ufe0f while spinning (Like a car drifting while doing donuts!) Change Parameters: Stronger B = Tighter spiral Stronger E = Faster drift \ud83c\udfae Play With These Settings! # TRY THESE CHANGES: B = [0, 0, 2.0] # Stronger magnet \u2192 tighter turns E = [0.5, 0, 0] # Stronger electric field \u2192 faster drift v = [0, 2.0, 1.0] # Different starting speed \u2192 wilder path \ud83d\udca1 Key Physics Without the Jargon Larmor Radius: How \"wide\" the spiral is (Bigger B \u2192 smaller radius) Drift Velocity: How fast it moves sideways (E\u00d7B direction) \ud83d\ude80 Where To Go Next Add gravity \u2192 See how particles fall while spinning! Try non-uniform fields \u2192 Crazy unpredictable paths! Simulate multiple particles \u2192 Like a mini particle accelerator! Want it simpler? Just ask! \ud83d\ude0a (Pro tip: Run this in Jupyter Notebook for interactive tweaking!)","title":"\ud83c\udf2a\ufe0f Lorentz Force Simulator: See Charged Particles Dance! \ud83c\udf2a\ufe0f"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#lorentz-force-simulator-see-charged-particles-dance","text":"(No scary math - just cool visuals and simple explanations!)","title":"\ud83c\udf2a\ufe0f Lorentz Force Simulator: See Charged Particles Dance! \ud83c\udf2a\ufe0f"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#what-is-lorentz-force","text":"It's the push/pull on charged particles in electric (\u26a1) and magnetic (\ud83e\uddf2) fields. Formula (for nerds): F = q(E + v \u00d7 B) (But we'll focus on what it DOES, not the math!)","title":"\ud83d\udd0d What is Lorentz Force?"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#where-this-matters-in-real-life","text":"Application How Lorentz Force Helps Particle Accelerators \ud83c\udf00 Keeps particles moving in perfect circles Mass Spectrometers \ud83d\udd0d Separates atoms by mass/charge ratio Fusion Reactors \u2600\ufe0f Traps super-hot plasma with magnetic fields","title":"\ud83d\ude80 Where This Matters in Real Life"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#lets-simulate-it-python-code","text":"(Try changing the numbers to see what happens!) import numpy as np import matplotlib.pyplot as plt from mpl_toolkits.mplot3d import Axes3D # Set up fields and particle q = 1.6e-19 # Charge (Coulombs) m = 9.1e-31 # Mass (kg) B = np.array([0, 0, 1.0]) # Magnetic field (Tesla) \u2192 along Z-axis E = np.array([0.1, 0, 0]) # Electric field (V/m) \u2192 along X-axis v = np.array([1.0, 0, 0]) # Initial velocity (m/s) # Time settings dt = 1e-10 # Time step (seconds) steps = 1000 positions = np.zeros((steps, 3)) # Simulation loop for i in range(1, steps): F = q * (E + np.cross(v, B)) # Lorentz Force! a = F / m # Acceleration v += a * dt positions[i] = positions[i-1] + v * dt # Plotting fig = plt.figure(figsize=(12, 6)) ax = fig.add_subplot(121, projection='3d') ax.plot(*positions.T, lw=2) ax.set_title(\"3D Trajectory\") ax.set_xlabel(\"X\"); ax.set_ylabel(\"Y\"); ax.set_zlabel(\"Z\") ax2 = fig.add_subplot(122) ax2.plot(positions[:,0], positions[:,1]) ax2.set_title(\"Top View (XY Plane)\") plt.tight_layout() plt.show()","title":"\ud83d\udcbb Let's Simulate It! (Python Code)"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#what-youll-see","text":"Pure Magnetic Field (B only): Particle spirals \ud83c\udf00 in a perfect helix (Like a rollercoaster with no end!) Electric + Magnetic (E \u22a5 B): Particle drifts sideways \u27a1\ufe0f while spinning (Like a car drifting while doing donuts!) Change Parameters: Stronger B = Tighter spiral Stronger E = Faster drift","title":"\ud83c\udf00 What You'll See"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#play-with-these-settings","text":"# TRY THESE CHANGES: B = [0, 0, 2.0] # Stronger magnet \u2192 tighter turns E = [0.5, 0, 0] # Stronger electric field \u2192 faster drift v = [0, 2.0, 1.0] # Different starting speed \u2192 wilder path","title":"\ud83c\udfae Play With These Settings!"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#key-physics-without-the-jargon","text":"Larmor Radius: How \"wide\" the spiral is (Bigger B \u2192 smaller radius) Drift Velocity: How fast it moves sideways (E\u00d7B direction)","title":"\ud83d\udca1 Key Physics Without the Jargon"},{"location":"1%20Physics/4%20Electromagnetism/Problem_1/#where-to-go-next","text":"Add gravity \u2192 See how particles fall while spinning! Try non-uniform fields \u2192 Crazy unpredictable paths! Simulate multiple particles \u2192 Like a mini particle accelerator! Want it simpler? Just ask! \ud83d\ude0a (Pro tip: Run this in Jupyter Notebook for interactive tweaking!)","title":"\ud83d\ude80 Where To Go Next"},{"location":"1%20Physics/5%20Circuits/Problem_1/","text":"Problem 1 \u26a1 Equivalent Resistance Made Stupid Simple \u26a1 (No physics jargon, just straight-up clarity with emoji power!) \ud83c\udfaf Why Bother With This? \ud83d\udd0c Circuits get messy \u2013 too many resistors = headache. \ud83e\udde0 Graph theory turns chaos into order (like magic). \ud83d\udcbb Computers love this method \u2013 great for automation. \ud83d\udee0\ufe0f Tools You Need Graph Theory Basics \ud83d\udfe2 Nodes = Connection points (where wires meet). \ud83d\udd35 Edges = Resistors (with resistance values). Two Golden Rules # \u26a1 Resistance Rules for Normal People \u26a1 \ud83d\udd17 Series (One After Another) \u27a1 Total Resistance = Just Add Them! R_total = R\u2081 + R\u2082 + R\u2083 + ... Example: 2 + 3 + 5 = 10\u03a9 (Like stacking weights \u2013 total gets heavier!) \ud83d\udd04 Parallel (Side by Side) \u27a1 For TWO Resistors: R_total = (R\u2081 \u00d7 R\u2082) / (R\u2081 + R\u2082) Example: Two 4\u03a9 resistors: (4 \u00d7 4) / (4 + 4) = 2\u03a9 (Like two roads \u2013 traffic flows easier!) \u27a1 For THREE+ Resistors: 1. Multiply all: R\u2081 \u00d7 R\u2082 \u00d7 R\u2083 2. Divide by sum of pairs: (R\u2081R\u2082 + R\u2081R\u2083 + R\u2082R\u2083) Example: Three 2\u03a9 resistors: (2\u00d72\u00d72) / (4 + 4 + 4) = 8/12 \u2248 0.67\u03a9 (Yes, parallel reduces resistance \u2013 more paths = easier flow!) \ud83d\udca1 Pro Tips: \u2705 Series: More resistors = Higher total resistance \u2705 Parallel: More resistors = Lower total resistance \u2705 Always convert parallel to two resistors first if possible! \ud83d\udd0d Step-by-Step Simplification 1\ufe0f\u20e3 Find Resistors in Series (Straight-Line Gang) Look for: Resistors connected end-to-end with no splits . Action: Replace them with one big resistor (sum them up). Example: - R\u2081 = 2\u03a9 + R\u2082 = 3\u03a9 \u2192 Total = 5\u03a9 \u2705 2\ufe0f\u20e3 Find Resistors in Parallel (Side-by-Side Squad) Look for: Resistors sharing the same start & end points . Action: Use the parallel formula to merge them. Example: - R\u2081 = 4\u03a9 || R\u2082 = 4\u03a9 \u2192 Total = 2\u03a9 \u2705 3\ufe0f\u20e3 Repeat Until Only One Resistor Remains Keep simplifying series & parallel until you get one final R . \ud83d\udcbb Let\u2019s Code It! (Python Example) (For those who want automation!) import networkx as nx def simplify_circuit(G): while True: # 1. Check if we're done (only 1 resistor left) if G.number_of_edges() == 1: return list(G.edges(data=True))[0][2]['resistance'] # 2. Try simplifying series resistors simplified = False for node in list(G.nodes()): neighbors = list(G.neighbors(node)) if len(neighbors) == 2: # Series candidate R1 = G[node][neighbors[0]]['resistance'] R2 = G[node][neighbors[1]]['resistance'] G.remove_node(node) G.add_edge(neighbors[0], neighbors[1], resistance=R1 + R2) simplified = True break if simplified: continue # 3. Try simplifying parallel resistors for u, v in list(G.edges()): if G.number_of_edges(u, v) > 1: # Parallel resistors total_R = 1 / sum(1 / G[u][v][k]['resistance'] for k in G[u][v]) G.remove_edges_from(list(G.edges(u, v))) G.add_edge(u, v, resistance=total_R) simplified = True break if not simplified: break # Can't simplify further return \"Complex circuit! Need advanced methods.\" # Example usage G = nx.Graph() G.add_edge('A', 'B', resistance=2) G.add_edge('B', 'C', resistance=3) G.add_edge('A', 'C', resistance=6) print(\"Total resistance:\", simplify_circuit(G)) \ud83d\udcca Real-World Examples 1\ufe0f\u20e3 Simple Series Circuit A --[2\u03a9]-- B --[3\u03a9]-- C Total = 2 + 3 = 5\u03a9 2\ufe0f\u20e3 Simple Parallel Circuit A --[4\u03a9]-- B A --[4\u03a9]-- B Total = 2\u03a9 3\ufe0f\u20e3 Mixed Circuit A --[2\u03a9]-- B --[3\u03a9]-- C A --[6\u03a9]-- C Total = 4\u03a9 (after simplification)","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#equivalent-resistance-made-stupid-simple","text":"(No physics jargon, just straight-up clarity with emoji power!)","title":"\u26a1 Equivalent Resistance Made Stupid Simple \u26a1"},{"location":"1%20Physics/5%20Circuits/Problem_1/#why-bother-with-this","text":"\ud83d\udd0c Circuits get messy \u2013 too many resistors = headache. \ud83e\udde0 Graph theory turns chaos into order (like magic). \ud83d\udcbb Computers love this method \u2013 great for automation.","title":"\ud83c\udfaf Why Bother With This?"},{"location":"1%20Physics/5%20Circuits/Problem_1/#tools-you-need","text":"Graph Theory Basics \ud83d\udfe2 Nodes = Connection points (where wires meet). \ud83d\udd35 Edges = Resistors (with resistance values). Two Golden Rules # \u26a1 Resistance Rules for Normal People \u26a1","title":"\ud83d\udee0\ufe0f Tools You Need"},{"location":"1%20Physics/5%20Circuits/Problem_1/#series-one-after-another","text":"\u27a1 Total Resistance = Just Add Them! R_total = R\u2081 + R\u2082 + R\u2083 + ... Example: 2 + 3 + 5 = 10\u03a9 (Like stacking weights \u2013 total gets heavier!)","title":"\ud83d\udd17 Series (One After Another)"},{"location":"1%20Physics/5%20Circuits/Problem_1/#parallel-side-by-side","text":"\u27a1 For TWO Resistors: R_total = (R\u2081 \u00d7 R\u2082) / (R\u2081 + R\u2082) Example: Two 4\u03a9 resistors: (4 \u00d7 4) / (4 + 4) = 2\u03a9 (Like two roads \u2013 traffic flows easier!) \u27a1 For THREE+ Resistors: 1. Multiply all: R\u2081 \u00d7 R\u2082 \u00d7 R\u2083 2. Divide by sum of pairs: (R\u2081R\u2082 + R\u2081R\u2083 + R\u2082R\u2083) Example: Three 2\u03a9 resistors: (2\u00d72\u00d72) / (4 + 4 + 4) = 8/12 \u2248 0.67\u03a9 (Yes, parallel reduces resistance \u2013 more paths = easier flow!)","title":"\ud83d\udd04 Parallel (Side by Side)"},{"location":"1%20Physics/5%20Circuits/Problem_1/#pro-tips","text":"\u2705 Series: More resistors = Higher total resistance \u2705 Parallel: More resistors = Lower total resistance \u2705 Always convert parallel to two resistors first if possible!","title":"\ud83d\udca1 Pro Tips:"},{"location":"1%20Physics/5%20Circuits/Problem_1/#step-by-step-simplification","text":"","title":"\ud83d\udd0d Step-by-Step Simplification"},{"location":"1%20Physics/5%20Circuits/Problem_1/#1-find-resistors-in-series-straight-line-gang","text":"Look for: Resistors connected end-to-end with no splits . Action: Replace them with one big resistor (sum them up). Example: - R\u2081 = 2\u03a9 + R\u2082 = 3\u03a9 \u2192 Total = 5\u03a9 \u2705","title":"1\ufe0f\u20e3 Find Resistors in Series (Straight-Line Gang)"},{"location":"1%20Physics/5%20Circuits/Problem_1/#2-find-resistors-in-parallel-side-by-side-squad","text":"Look for: Resistors sharing the same start & end points . Action: Use the parallel formula to merge them. Example: - R\u2081 = 4\u03a9 || R\u2082 = 4\u03a9 \u2192 Total = 2\u03a9 \u2705","title":"2\ufe0f\u20e3 Find Resistors in Parallel (Side-by-Side Squad)"},{"location":"1%20Physics/5%20Circuits/Problem_1/#3-repeat-until-only-one-resistor-remains","text":"Keep simplifying series & parallel until you get one final R .","title":"3\ufe0f\u20e3 Repeat Until Only One Resistor Remains"},{"location":"1%20Physics/5%20Circuits/Problem_1/#lets-code-it-python-example","text":"(For those who want automation!) import networkx as nx def simplify_circuit(G): while True: # 1. Check if we're done (only 1 resistor left) if G.number_of_edges() == 1: return list(G.edges(data=True))[0][2]['resistance'] # 2. Try simplifying series resistors simplified = False for node in list(G.nodes()): neighbors = list(G.neighbors(node)) if len(neighbors) == 2: # Series candidate R1 = G[node][neighbors[0]]['resistance'] R2 = G[node][neighbors[1]]['resistance'] G.remove_node(node) G.add_edge(neighbors[0], neighbors[1], resistance=R1 + R2) simplified = True break if simplified: continue # 3. Try simplifying parallel resistors for u, v in list(G.edges()): if G.number_of_edges(u, v) > 1: # Parallel resistors total_R = 1 / sum(1 / G[u][v][k]['resistance'] for k in G[u][v]) G.remove_edges_from(list(G.edges(u, v))) G.add_edge(u, v, resistance=total_R) simplified = True break if not simplified: break # Can't simplify further return \"Complex circuit! Need advanced methods.\" # Example usage G = nx.Graph() G.add_edge('A', 'B', resistance=2) G.add_edge('B', 'C', resistance=3) G.add_edge('A', 'C', resistance=6) print(\"Total resistance:\", simplify_circuit(G))","title":"\ud83d\udcbb Let\u2019s Code It! (Python Example)"},{"location":"1%20Physics/5%20Circuits/Problem_1/#real-world-examples","text":"","title":"\ud83d\udcca Real-World Examples"},{"location":"1%20Physics/5%20Circuits/Problem_1/#1-simple-series-circuit","text":"A --[2\u03a9]-- B --[3\u03a9]-- C Total = 2 + 3 = 5\u03a9","title":"1\ufe0f\u20e3 Simple Series Circuit"},{"location":"1%20Physics/5%20Circuits/Problem_1/#2-simple-parallel-circuit","text":"A --[4\u03a9]-- B A --[4\u03a9]-- B Total = 2\u03a9","title":"2\ufe0f\u20e3 Simple Parallel Circuit"},{"location":"1%20Physics/5%20Circuits/Problem_1/#3-mixed-circuit","text":"A --[2\u03a9]-- B --[3\u03a9]-- C A --[6\u03a9]-- C Total = 4\u03a9 (after simplification)","title":"3\ufe0f\u20e3 Mixed Circuit"},{"location":"1%20Physics/6%20Statistics/Problem_1/","text":"Problem 1 \ud83d\udcca Central Limit Theorem: Visual Magic in Statistics! \ud83c\udfb2 What is CLT? \"No matter how weird your data looks, average enough of it \u2192 becomes normal!\" \u2705 Works for ANY distribution (uniform, exponential, even weird shapes!) \u2705 Bigger samples = More perfect bell curve \ud83d\udcbb Let's Simulate It! (Python Code) import numpy as np import matplotlib.pyplot as plt import seaborn as sns # Set up 3 crazy different distributions distributions = { \"Uniform\": np.random.uniform(0, 10, 100000), # Flat like a table \"Exponential\": np.random.exponential(1, 100000), # Skewed like a slide \"Weird Mix\": 0.5*np.random.normal(5,1,100000) + 0.5*np.random.poisson(3,100000) # Frankenstein data! } # Sampling settings sample_sizes = [5, 10, 30, 50] # Try different sizes! n_samples = 1000 # Number of sample means to calculate plt.figure(figsize=(15,10)) for i, (name, population) in enumerate(distributions.items()): for j, n in enumerate(sample_sizes): # Calculate 1000 sample means sample_means = [np.mean(np.random.choice(population, n)) for _ in range(n_samples)] # Plot plt.subplot(3, 4, i*4 + j + 1) sns.histplot(sample_means, kde=True, color='skyblue') plt.title(f\"{name}\\nn={n}\", fontsize=10) plt.xlim(min(population), max(population)) plt.tight_layout() plt.show() \ud83d\udd0d What You'll Discover 1\ufe0f\u20e3 Small Samples (n=5) Histogram looks wild \u2192 Still resembles original shape Example: Exponential stays lopsided 2\ufe0f\u20e3 Medium Samples (n=30) Starts looking smoother \u2192 Baby bell curve forming! 3\ufe0f\u20e3 Large Samples (n=50+) Perfect normal distribution \u2192 Magic of CLT! \ud83c\udfa9\u2728 Even for \"Weird Mix\" data! \ud83c\udf0e Real-World Superpowers Application How CLT Saves the Day Elections \ud83d\uddf3\ufe0f Predict winner from small polls accurately Drug Trials \ud83d\udc8a Prove medicine works despite individual differences Quality Control \ud83c\udfed Detect faulty machines from sample testing \ud83c\udfae Play With These Settings! # TRY THESE TWEAKS: sample_sizes = [2, 10, 50, 100] # Watch how tiny samples struggle! n_samples = 5000 # More means = smoother curves \ud83d\udca1 Golden Insights Sample size >30 \u2192 Usually good enough for normality Skewed original data? \u2192 Needs bigger samples to \"normalize\" CLT explains why averages are everywhere (test scores, heights, etc.) \ud83d\ude80 Next-Level Exploration Add \"Crazy Distribution\" \u2192 Like two humps (bimodal) Test tiny samples (n=2) \u2192 See CLT fail dramatically Plot standard deviation \u2192 Shows shrinking spread with bigger n Run this in Jupyter Notebook to interactively play! \"The CLT is why statisticians sleep well at night.\" \ud83d\ude34\ud83d\udcc8","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/6%20Statistics/Problem_1/#central-limit-theorem-visual-magic-in-statistics","text":"","title":"\ud83d\udcca Central Limit Theorem: Visual Magic in Statistics!"},{"location":"1%20Physics/6%20Statistics/Problem_1/#what-is-clt","text":"\"No matter how weird your data looks, average enough of it \u2192 becomes normal!\" \u2705 Works for ANY distribution (uniform, exponential, even weird shapes!) \u2705 Bigger samples = More perfect bell curve","title":"\ud83c\udfb2 What is CLT?"},{"location":"1%20Physics/6%20Statistics/Problem_1/#lets-simulate-it-python-code","text":"import numpy as np import matplotlib.pyplot as plt import seaborn as sns # Set up 3 crazy different distributions distributions = { \"Uniform\": np.random.uniform(0, 10, 100000), # Flat like a table \"Exponential\": np.random.exponential(1, 100000), # Skewed like a slide \"Weird Mix\": 0.5*np.random.normal(5,1,100000) + 0.5*np.random.poisson(3,100000) # Frankenstein data! } # Sampling settings sample_sizes = [5, 10, 30, 50] # Try different sizes! n_samples = 1000 # Number of sample means to calculate plt.figure(figsize=(15,10)) for i, (name, population) in enumerate(distributions.items()): for j, n in enumerate(sample_sizes): # Calculate 1000 sample means sample_means = [np.mean(np.random.choice(population, n)) for _ in range(n_samples)] # Plot plt.subplot(3, 4, i*4 + j + 1) sns.histplot(sample_means, kde=True, color='skyblue') plt.title(f\"{name}\\nn={n}\", fontsize=10) plt.xlim(min(population), max(population)) plt.tight_layout() plt.show()","title":"\ud83d\udcbb Let's Simulate It! (Python Code)"},{"location":"1%20Physics/6%20Statistics/Problem_1/#what-youll-discover","text":"","title":"\ud83d\udd0d What You'll Discover"},{"location":"1%20Physics/6%20Statistics/Problem_1/#1-small-samples-n5","text":"Histogram looks wild \u2192 Still resembles original shape Example: Exponential stays lopsided","title":"1\ufe0f\u20e3 Small Samples (n=5)"},{"location":"1%20Physics/6%20Statistics/Problem_1/#2-medium-samples-n30","text":"Starts looking smoother \u2192 Baby bell curve forming!","title":"2\ufe0f\u20e3 Medium Samples (n=30)"},{"location":"1%20Physics/6%20Statistics/Problem_1/#3-large-samples-n50","text":"Perfect normal distribution \u2192 Magic of CLT! \ud83c\udfa9\u2728 Even for \"Weird Mix\" data!","title":"3\ufe0f\u20e3 Large Samples (n=50+)"},{"location":"1%20Physics/6%20Statistics/Problem_1/#real-world-superpowers","text":"Application How CLT Saves the Day Elections \ud83d\uddf3\ufe0f Predict winner from small polls accurately Drug Trials \ud83d\udc8a Prove medicine works despite individual differences Quality Control \ud83c\udfed Detect faulty machines from sample testing","title":"\ud83c\udf0e Real-World Superpowers"},{"location":"1%20Physics/6%20Statistics/Problem_1/#play-with-these-settings","text":"# TRY THESE TWEAKS: sample_sizes = [2, 10, 50, 100] # Watch how tiny samples struggle! n_samples = 5000 # More means = smoother curves","title":"\ud83c\udfae Play With These Settings!"},{"location":"1%20Physics/6%20Statistics/Problem_1/#golden-insights","text":"Sample size >30 \u2192 Usually good enough for normality Skewed original data? \u2192 Needs bigger samples to \"normalize\" CLT explains why averages are everywhere (test scores, heights, etc.)","title":"\ud83d\udca1 Golden Insights"},{"location":"1%20Physics/6%20Statistics/Problem_1/#next-level-exploration","text":"Add \"Crazy Distribution\" \u2192 Like two humps (bimodal) Test tiny samples (n=2) \u2192 See CLT fail dramatically Plot standard deviation \u2192 Shows shrinking spread with bigger n Run this in Jupyter Notebook to interactively play! \"The CLT is why statisticians sleep well at night.\" \ud83d\ude34\ud83d\udcc8","title":"\ud83d\ude80 Next-Level Exploration"},{"location":"1%20Physics/6%20Statistics/Problem_2/","text":"Problem 2 \ud83c\udfaf Estimating \u03c0 with Randomness: A Monte Carlo Adventure \ud83c\udf31 The Core Idea \"Throw darts randomly \u2192 Count hits \u2192 Estimate \u03c0!\" \u2705 Circle Method : Drop points in a square & count circle hits \u2705 Buffon\u2019s Needle : Drop needles on lines & count crosses Part 1: The Circle Method \ud83d\udfe1 \ud83c\udfaf How It Works Draw a unit circle (radius=1) inside a 2\u00d72 square Randomly throw \"darts\" (points) at the square Count hits inside circle vs total throws \u2192 Estimate \u03c0! Formula : \\( \\(\\pi \\approx 4 \\times \\frac{\\text{Points Inside Circle}}{\\text{Total Points}}\\) \\) \ud83d\udcbb Python Simulation def buffons_needle(n_needles): crosses = 0 plt.figure(figsize=(10,5)) for i in range(n_needles): x = np.random.uniform(0, 1) # Line spacing = 1 \u03b8 = np.random.uniform(0, np.pi/2) tip = x + np.sin(\u03b8) # Needle length = 1 # Visualize first 100 needles if i < 100: plt.plot([x, x+np.cos(\u03b8)], [0, np.sin(\u03b8)], color='red' if tip > 1 else 'blue', alpha=0.7) if tip > 1: crosses += 1 plt.hlines(0, 0, 1, colors='black', linewidths=2) plt.hlines(1, 0, 1, colors='black', linewidths=2) plt.title(f\"First 100 Needles (Total crosses: {crosses}/{n_needles})\") plt.axis('equal') plt.show() return (2 * n_needles) / crosses if crosses > 0 else 0 print(f\"\u03c0 \u2248 {buffons_needle(100_000):.5f}\") \ud83d\udcca Key Observations 100 points : Wild estimate (e.g., \u03c0\u22483.2) 10,000 points : Close! (e.g., \u03c0\u22483.1416) More points = Better accuracy (but slower) Part 2: Buffon\u2019s Needle Method \ud83d\udccc \ud83c\udfaf How It Works Draw parallel lines (spacing = needle length) Drop needles randomly Count line crosses \u2192 Estimate \u03c0! Formula : \\( \\(\\pi \\approx \\frac{2 \\times \\text{Total Needles}}{\\text{Crosses}}\\) \\) \ud83d\udcbb Python Simulation def buffons_needle(n_needles, needle_length=1, line_spacing=1): crosses = 0 for _ in range(n_needles): # Random needle position and angle x = np.random.uniform(0, line_spacing) \u03b8 = np.random.uniform(0, np.pi/2) # Check if needle crosses line if x <= (needle_length/2)*np.sin(\u03b8): crosses += 1 pi_estimate = (2 * n_needles) / crosses if crosses > 0 else 0 return pi_estimate print(f\"\u03c0 \u2248 {buffons_needle(100_000):.5f}\") # Try increasing numbers! \ud83d\udcca Method Comparison Method Pros Cons Circle \ud83d\udfe1 Faster convergence Needs many points Needle \ud83d\udccc Cool physical intuition Slower convergence \ud83c\udf0d Real-World Applications Quantum Physics : Particle behavior modeling Finance : Risk assessment in stock markets Computer Graphics : Ray tracing algorithms \ud83d\ude80 Try These Experiments! Vary point/needle counts \u2192 Watch accuracy improve Change needle length in Buffon\u2019s method \u2192 See formula change Combine both methods \u2192 Average the estimates \"Monte Carlo methods: When math meets randomness!\" \ud83c\udfb2\u2728 Run the code yourself to watch \u03c0 emerge from chaos!","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#problem-2","text":"","title":"Problem 2"},{"location":"1%20Physics/6%20Statistics/Problem_2/#estimating-with-randomness-a-monte-carlo-adventure","text":"","title":"\ud83c\udfaf Estimating \u03c0 with Randomness: A Monte Carlo Adventure"},{"location":"1%20Physics/6%20Statistics/Problem_2/#the-core-idea","text":"\"Throw darts randomly \u2192 Count hits \u2192 Estimate \u03c0!\" \u2705 Circle Method : Drop points in a square & count circle hits \u2705 Buffon\u2019s Needle : Drop needles on lines & count crosses","title":"\ud83c\udf31 The Core Idea"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-1-the-circle-method","text":"","title":"Part 1: The Circle Method \ud83d\udfe1"},{"location":"1%20Physics/6%20Statistics/Problem_2/#how-it-works","text":"Draw a unit circle (radius=1) inside a 2\u00d72 square Randomly throw \"darts\" (points) at the square Count hits inside circle vs total throws \u2192 Estimate \u03c0! Formula : \\( \\(\\pi \\approx 4 \\times \\frac{\\text{Points Inside Circle}}{\\text{Total Points}}\\) \\)","title":"\ud83c\udfaf How It Works"},{"location":"1%20Physics/6%20Statistics/Problem_2/#python-simulation","text":"def buffons_needle(n_needles): crosses = 0 plt.figure(figsize=(10,5)) for i in range(n_needles): x = np.random.uniform(0, 1) # Line spacing = 1 \u03b8 = np.random.uniform(0, np.pi/2) tip = x + np.sin(\u03b8) # Needle length = 1 # Visualize first 100 needles if i < 100: plt.plot([x, x+np.cos(\u03b8)], [0, np.sin(\u03b8)], color='red' if tip > 1 else 'blue', alpha=0.7) if tip > 1: crosses += 1 plt.hlines(0, 0, 1, colors='black', linewidths=2) plt.hlines(1, 0, 1, colors='black', linewidths=2) plt.title(f\"First 100 Needles (Total crosses: {crosses}/{n_needles})\") plt.axis('equal') plt.show() return (2 * n_needles) / crosses if crosses > 0 else 0 print(f\"\u03c0 \u2248 {buffons_needle(100_000):.5f}\")","title":"\ud83d\udcbb Python Simulation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#key-observations","text":"100 points : Wild estimate (e.g., \u03c0\u22483.2) 10,000 points : Close! (e.g., \u03c0\u22483.1416) More points = Better accuracy (but slower)","title":"\ud83d\udcca Key Observations"},{"location":"1%20Physics/6%20Statistics/Problem_2/#part-2-buffons-needle-method","text":"","title":"Part 2: Buffon\u2019s Needle Method \ud83d\udccc"},{"location":"1%20Physics/6%20Statistics/Problem_2/#how-it-works_1","text":"Draw parallel lines (spacing = needle length) Drop needles randomly Count line crosses \u2192 Estimate \u03c0! Formula : \\( \\(\\pi \\approx \\frac{2 \\times \\text{Total Needles}}{\\text{Crosses}}\\) \\)","title":"\ud83c\udfaf How It Works"},{"location":"1%20Physics/6%20Statistics/Problem_2/#python-simulation_1","text":"def buffons_needle(n_needles, needle_length=1, line_spacing=1): crosses = 0 for _ in range(n_needles): # Random needle position and angle x = np.random.uniform(0, line_spacing) \u03b8 = np.random.uniform(0, np.pi/2) # Check if needle crosses line if x <= (needle_length/2)*np.sin(\u03b8): crosses += 1 pi_estimate = (2 * n_needles) / crosses if crosses > 0 else 0 return pi_estimate print(f\"\u03c0 \u2248 {buffons_needle(100_000):.5f}\") # Try increasing numbers!","title":"\ud83d\udcbb Python Simulation"},{"location":"1%20Physics/6%20Statistics/Problem_2/#method-comparison","text":"Method Pros Cons Circle \ud83d\udfe1 Faster convergence Needs many points Needle \ud83d\udccc Cool physical intuition Slower convergence","title":"\ud83d\udcca Method Comparison"},{"location":"1%20Physics/6%20Statistics/Problem_2/#real-world-applications","text":"Quantum Physics : Particle behavior modeling Finance : Risk assessment in stock markets Computer Graphics : Ray tracing algorithms","title":"\ud83c\udf0d Real-World Applications"},{"location":"1%20Physics/6%20Statistics/Problem_2/#try-these-experiments","text":"Vary point/needle counts \u2192 Watch accuracy improve Change needle length in Buffon\u2019s method \u2192 See formula change Combine both methods \u2192 Average the estimates \"Monte Carlo methods: When math meets randomness!\" \ud83c\udfb2\u2728 Run the code yourself to watch \u03c0 emerge from chaos!","title":"\ud83d\ude80 Try These Experiments!"},{"location":"1%20Physics/7%20Measurements/Problem_1/","text":"Problem 1 \ud83c\udf0d Measuring Earth's Gravity with a DIY Pendulum \ud83d\udcdd Materials Checklist \ud83e\uddf5 String (1-1.5m long) \u2696\ufe0f Weight (keys, small bag of sugar, or anything dense) \u23f1\ufe0f Stopwatch (phone works fine) \ud83d\udccf Ruler/measuring tape \ud83d\udd27 Setup (2 Minutes) Tie weight to string Measure length ( L ) from pivot to weight's center \ud83d\udcd0 Uncertainty : If your ruler has 1mm marks, \u0394L = \u00b10.5mm Hang from a fixed point (doorframe, ceiling hook) (Keep angles <15\u00b0 for accurate results!) \u23f3 Data Collection Time 10 swings (back-and-forth = 1 swing) Repeat 10 times (reduces timing errors) \ud83d\udcca Example Data Table Trial Time for 10 swings (s) 1 14.21 2 14.18 ... ... 10 14.25 Calculations: - Mean time (T\u2081\u2080) : Average of all trials - Standard deviation (\u03c3) : Measures your timing consistency - Uncertainty (\u0394T\u2081\u2080) : \u03c3/\u221a10 \ud83e\uddee The Math (Simplified) 1. Period (T) per swing $$ T = \\frac{T_{10}}{10} $$ (Example: 14.2s/10 = 1.42s) 2. Gravity Formula \\[ g = \\frac{4\\pi^2 L}{T^2} \\] Example : - L = 1.00m \u00b10.0005m - T = 1.42s \u00b10.01s \u2192 g \u2248 9.82 m/s\u00b2 3. Uncertainty Propagation \\[ \\frac{\\Delta g}{g} = \\sqrt{\\left(\\frac{\\Delta L}{L}\\right)^2 + \\left(2\\frac{\\Delta T}{T}\\right)^2} \\] (This accounts for errors in both length and timing!) \ud83d\udcc9 Expected Results vs Reality Location Standard g (m/s\u00b2) Your Measurement Sea Level 9.81 [Your Value] High Altitude ~9.78 Key Insight : - Your result should be within \u00b10.1 m/s\u00b2 of 9.81 if done carefully! \ud83d\udd0d Error Analysis Major Error Sources Angle >15\u00b0 \u2192 Formula breaks down String stretch \u2192 Changes effective L Air resistance \u2192 Slows pendulum slightly Timing reflexes \u2192 Human reaction time (~0.2s error) Pro Tip : Use video + frame counting for better timing! -","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#problem-1","text":"","title":"Problem 1"},{"location":"1%20Physics/7%20Measurements/Problem_1/#measuring-earths-gravity-with-a-diy-pendulum","text":"","title":"\ud83c\udf0d Measuring Earth's Gravity with a DIY Pendulum"},{"location":"1%20Physics/7%20Measurements/Problem_1/#materials-checklist","text":"\ud83e\uddf5 String (1-1.5m long) \u2696\ufe0f Weight (keys, small bag of sugar, or anything dense) \u23f1\ufe0f Stopwatch (phone works fine) \ud83d\udccf Ruler/measuring tape","title":"\ud83d\udcdd Materials Checklist"},{"location":"1%20Physics/7%20Measurements/Problem_1/#setup-2-minutes","text":"Tie weight to string Measure length ( L ) from pivot to weight's center \ud83d\udcd0 Uncertainty : If your ruler has 1mm marks, \u0394L = \u00b10.5mm Hang from a fixed point (doorframe, ceiling hook) (Keep angles <15\u00b0 for accurate results!)","title":"\ud83d\udd27 Setup (2 Minutes)"},{"location":"1%20Physics/7%20Measurements/Problem_1/#data-collection","text":"Time 10 swings (back-and-forth = 1 swing) Repeat 10 times (reduces timing errors)","title":"\u23f3 Data Collection"},{"location":"1%20Physics/7%20Measurements/Problem_1/#example-data-table","text":"Trial Time for 10 swings (s) 1 14.21 2 14.18 ... ... 10 14.25 Calculations: - Mean time (T\u2081\u2080) : Average of all trials - Standard deviation (\u03c3) : Measures your timing consistency - Uncertainty (\u0394T\u2081\u2080) : \u03c3/\u221a10","title":"\ud83d\udcca Example Data Table"},{"location":"1%20Physics/7%20Measurements/Problem_1/#the-math-simplified","text":"","title":"\ud83e\uddee The Math (Simplified)"},{"location":"1%20Physics/7%20Measurements/Problem_1/#1-period-t-per-swing","text":"$$ T = \\frac{T_{10}}{10} $$ (Example: 14.2s/10 = 1.42s)","title":"1. Period (T) per swing"},{"location":"1%20Physics/7%20Measurements/Problem_1/#2-gravity-formula","text":"\\[ g = \\frac{4\\pi^2 L}{T^2} \\] Example : - L = 1.00m \u00b10.0005m - T = 1.42s \u00b10.01s \u2192 g \u2248 9.82 m/s\u00b2","title":"2. Gravity Formula"},{"location":"1%20Physics/7%20Measurements/Problem_1/#3-uncertainty-propagation","text":"\\[ \\frac{\\Delta g}{g} = \\sqrt{\\left(\\frac{\\Delta L}{L}\\right)^2 + \\left(2\\frac{\\Delta T}{T}\\right)^2} \\] (This accounts for errors in both length and timing!)","title":"3. Uncertainty Propagation"},{"location":"1%20Physics/7%20Measurements/Problem_1/#expected-results-vs-reality","text":"Location Standard g (m/s\u00b2) Your Measurement Sea Level 9.81 [Your Value] High Altitude ~9.78 Key Insight : - Your result should be within \u00b10.1 m/s\u00b2 of 9.81 if done carefully!","title":"\ud83d\udcc9 Expected Results vs Reality"},{"location":"1%20Physics/7%20Measurements/Problem_1/#error-analysis","text":"","title":"\ud83d\udd0d Error Analysis"},{"location":"1%20Physics/7%20Measurements/Problem_1/#major-error-sources","text":"Angle >15\u00b0 \u2192 Formula breaks down String stretch \u2192 Changes effective L Air resistance \u2192 Slows pendulum slightly Timing reflexes \u2192 Human reaction time (~0.2s error) Pro Tip : Use video + frame counting for better timing! -","title":"Major Error Sources"},{"location":"2%20Mathematics/1%20Linear_algebra/","text":"Linear Algebra","title":"Linear Algebra"},{"location":"2%20Mathematics/1%20Linear_algebra/#linear-algebra","text":"","title":"Linear Algebra"},{"location":"2%20Mathematics/2%20Analytic_geometry/","text":"Analytic geometry","title":"Analytic geometry"},{"location":"2%20Mathematics/2%20Analytic_geometry/#analytic-geometry","text":"","title":"Analytic geometry"},{"location":"2%20Mathematics/3%20Calculus/","text":"Calculus","title":"Calculus"},{"location":"2%20Mathematics/3%20Calculus/#calculus","text":"","title":"Calculus"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/","text":"Set Theory","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_02%20Set_Theory/#set-theory","text":"","title":"Set Theory"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/","text":"Relations","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_03%20Relations/#relations","text":"","title":"Relations"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/","text":"Functions","title":"Functions"},{"location":"3%20Discret_Mathematics/1%20Set%20Theory%20and%20.../_04%20Functions/#functions","text":"","title":"Functions"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/","text":"Combinatorics","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_05%20Combinatorics/#combinatorics","text":"","title":"Combinatorics"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/","text":"Number Theory","title":"Number Theory"},{"location":"3%20Discret_Mathematics/2%20Number%20Theory%20and%20.../_08%20Number_Theory/#number-theory","text":"","title":"Number Theory"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/","text":"Sequences and Series","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_06%20Sequences_and_Series/#sequences-and-series","text":"","title":"Sequences and Series"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/","text":"Induction","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_07%20Induction/#induction","text":"","title":"Induction"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/","text":"Recurrence","title":"Recurrence"},{"location":"3%20Discret_Mathematics/3%20Recurrence%20and%20.../_09%20Recurrence/#recurrence","text":"","title":"Recurrence"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/","text":"Graph Theory","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/4%20Graph%20Theory%20and%20.../_10%20Graph_Theory/#graph-theory","text":"","title":"Graph Theory"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/","text":"Logic","title":"Logic"},{"location":"3%20Discret_Mathematics/5%20Logic/_01%20Logic/#logic","text":"","title":"Logic"}]}